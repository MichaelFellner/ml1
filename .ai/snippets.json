{
  "mlteach_snippets": {
    "interactive_level_class": {
      "description": "Creates a new interactive level class extending InteractiveLevelTemplate",
      "code": "class ${1:LevelName}Level extends InteractiveLevelTemplate {\n    constructor() {\n        super({\n            id: '${2:level-id}',\n            name: '${3:Level Display Name}',\n            type: 'interactive',\n            description: '${4:Level description}',\n            \n            targetFunction: { w: ${5:7.0}, b: ${6:0} },\n            \n            controls: [\n                {\n                    id: 'w',\n                    label: 'Weight Parameter',\n                    min: ${7:0},\n                    max: ${8:15},\n                    step: ${9:0.1},\n                    default: ${10:1.0}\n                }\n            ],\n            \n            validation: {\n                tolerance: ${11:0.05}\n            },\n            \n            trackProgress: true,\n            debug: false\n        });\n    }\n    \n    async setup() {\n        await super.setup();\n        ${12:// Custom setup logic}\n        this.log('${1:LevelName} setup complete');\n    }\n    \n    _generateVisualizationContent() {\n        return `\n            <div class=\"visualization-content\">\n                ${13:<!-- Custom visualization HTML -->}\n            </div>\n        `;\n    }\n    \n    async onTeardown() {\n        await super.onTeardown();\n        ${14:// Custom cleanup}\n        this.log('${1:LevelName} cleanup complete');\n    }\n}"
    },
    
    "base_level_class": {
      "description": "Creates a new base level class extending BaseLevelTemplate",
      "code": "class ${1:LevelName}Level extends BaseLevelTemplate {\n    constructor() {\n        super({\n            id: '${2:level-id}',\n            name: '${3:Level Display Name}',\n            type: '${4:tutorial}', // tutorial, demonstration, custom\n            description: '${5:Level description}',\n            trackProgress: true,\n            debug: false\n        });\n    }\n    \n    async setup() {\n        await super.setup();\n        ${6:// Custom setup logic}\n        this.log('${1:LevelName} setup complete');\n    }\n    \n    _generateMainContent() {\n        return `\n            <div class=\"level-content\">\n                <h3>${3:Level Display Name}</h3>\n                <p>${5:Level description}</p>\n                ${7:<!-- Custom content -->}\n                \n                <button onclick=\"currentLevel.completeLevel({score: 100})\">\n                    Complete Level\n                </button>\n            </div>\n        `;\n    }\n    \n    async onTeardown() {\n        await super.onTeardown();\n        ${8:// Custom cleanup}\n        this.log('${1:LevelName} cleanup complete');\n    }\n}"
    },
    
    "level_creation_function": {
      "description": "Creates the standard level creation function",
      "code": "/**\n * Creates and initializes the ${1:Level Name}\n */\nasync function create${2:LevelName}Level() {\n    try {\n        const level = new ${2:LevelName}Level();\n        await level.create();\n        \n        window.currentLevel = level;\n        return level;\n        \n    } catch (error) {\n        console.error('Failed to create ${1:Level Name}:', error);\n        \n        const container = document.getElementById('app');\n        if (container) {\n            container.innerHTML = `\n                <div style=\"padding: 40px; text-align: center; color: #ff6347;\">\n                    <h2>‚ö†Ô∏è Level Loading Error</h2>\n                    <p>Failed to load ${1:Level Name}. Please refresh the page.</p>\n                    <button onclick=\"location.reload()\" style=\"padding: 10px 20px; margin-top: 20px;\">\n                        üîÑ Refresh Page\n                    </button>\n                </div>\n            `;\n        }\n        \n        throw error;\n    }\n}\n\n// Export for modules and global usage\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { create${2:LevelName}Level };\n} else {\n    window.create${2:LevelName}Level = create${2:LevelName}Level;\n}"
    },
    
    "component_class": {
      "description": "Creates a new component extending the base Component class",
      "code": "class ${1:ComponentName} extends Component {\n    \n    get defaultConfig() {\n        return {\n            ${2:// Default configuration}\n        };\n    }\n    \n    get initialState() {\n        return {\n            ${3:// Initial state}\n        };\n    }\n    \n    mount() {\n        super.mount();\n        ${4:// Custom mounting logic}\n        this.setupEvents();\n    }\n    \n    render() {\n        return `\n            <div class=\"${5:component-class}\">\n                ${6:<!-- Component HTML -->}\n            </div>\n        `;\n    }\n    \n    setupEvents() {\n        ${7:// Event listeners setup}\n    }\n    \n    unmount() {\n        ${8:// Custom cleanup}\n        super.unmount();\n    }\n}"
    },
    
    "service_class": {
      "description": "Creates a new service class with static methods",
      "code": "/**\n * ${1:Service Name} - ${2:Service description}\n */\nclass ${3:ServiceName}Service {\n    \n    /**\n     * ${4:Method description}\n     * \n     * @param {${5:type}} ${6:parameter} - ${7:Parameter description}\n     * @returns {${8:type}} ${9:Return description}\n     */\n    static ${10:methodName}(${6:parameter}) {\n        ${11:// Implementation}\n    }\n    \n    /**\n     * Validates ${12:validation target}\n     * \n     * @param {Object} data - Data to validate\n     * @returns {Object} Validation result\n     */\n    static validate(data) {\n        ${13:// Validation logic}\n        return {\n            isValid: true,\n            errors: []\n        };\n    }\n}\n\n// Make service globally available\nwindow.${3:ServiceName}Service = ${3:ServiceName}Service;\n\n// Export for modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ${3:ServiceName}Service;\n}"
    },
    
    "gradient_descent_calculation": {
      "description": "Standard gradient descent calculation using the service",
      "code": "// Check if service is available\nif (typeof GradientDescentService !== 'undefined') {\n    const params = this.getParameters();\n    const { w, b } = params;\n    \n    // Calculate predictions\n    const predictions = ${1:dataPoints}.map(point => w * point.x + b);\n    const actual = ${1:dataPoints}.map(point => point.y);\n    \n    // Calculate loss\n    const loss = GradientDescentService.calculateL1Loss(predictions, actual);\n    \n    // Calculate gradients\n    const gradients = GradientDescentService.calculateGradient(\n        w, b, ${1:dataPoints}, '${2:L1}' // or 'L2'\n    );\n    \n    // Perform gradient descent step\n    const learningRate = ${3:0.01};\n    const newParams = GradientDescentService.performStep(\n        params, gradients, learningRate\n    );\n    \n    // Update parameters\n    this.updateParameters(newParams);\n    \n    ${4:// Update visualization or display}\n} else {\n    console.warn('GradientDescentService not available');\n}"
    },
    
    "state_management_integration": {
      "description": "Standard state management integration pattern",
      "code": "// Check if state management is available\nconst hasStateManagement = \n    typeof LevelProgressStore !== 'undefined' && \n    typeof GameStateStore !== 'undefined';\n\nif (hasStateManagement) {\n    // Save current parameters\n    GameStateStore.updateParameters(this.config.id, this.getParameters());\n    \n    // Track user action\n    GameStateStore.trackAction(this.config.id, '${1:action_name}', {\n        ${2:// Action data}\n    });\n    \n    // Complete level with progress tracking\n    LevelProgressStore.completeLevel(this.config.id, {\n        score: ${3:score},\n        solutions: this.getParameters(),\n        timeSpent: Date.now() - this.startTime,\n        attempts: this.attempts\n    });\n    \n    // Load previous state\n    const savedParams = GameStateStore.getParameters(this.config.id);\n    if (savedParams) {\n        this.updateParameters(savedParams);\n    }\n} else {\n    console.warn('State management not available');\n    ${4:// Fallback behavior}\n}"
    },
    
    "event_handling_pattern": {
      "description": "Standard event handling with cleanup",
      "code": "setupEvents() {\n    // Store bound handlers for cleanup\n    this.boundHandlers = {\n        ${1:eventName}: this.${2:handlerMethod}.bind(this)\n    };\n    \n    // Add event listeners with cleanup tracking\n    const ${3:element} = document.getElementById('${4:element-id}');\n    if (${3:element}) {\n        this.addEventListenerWithCleanup(\n            ${3:element}, \n            '${5:event-type}', \n            this.boundHandlers.${1:eventName}\n        );\n    }\n    \n    // Global event listeners\n    this.addEventListenerWithCleanup(\n        window, \n        '${6:window-event}', \n        this.boundHandlers.${1:eventName}\n    );\n}\n\n${2:handlerMethod}(event) {\n    ${7:// Event handling logic}\n    \n    // Prevent default if needed\n    event.preventDefault();\n    \n    // Dispatch custom event if needed\n    this.dispatchEvent('${8:custom-event}', {\n        ${9:// Event data}\n    });\n}"
    },
    
    "parameter_validation": {
      "description": "Standard parameter validation pattern",
      "code": "validateParameters(testParameters = null) {\n    const params = testParameters || this.getParameters();\n    const target = this.config.targetFunction;\n    const tolerance = this.config.validation.tolerance || 0.05;\n    \n    let totalError = 0;\n    let errorCount = 0;\n    const details = [];\n    \n    // Validate each parameter\n    this.config.controls.forEach(control => {\n        const paramValue = params[control.id];\n        const targetValue = target[control.id];\n        \n        if (targetValue !== undefined) {\n            const error = Math.abs(paramValue - targetValue);\n            const relativeError = Math.abs(error / targetValue);\n            \n            totalError += relativeError;\n            errorCount++;\n            \n            const status = relativeError <= tolerance ? '‚úÖ' : '‚ùå';\n            details.push(\n                `${control.label}: ${paramValue.toFixed(2)} ` +\n                `(target: ${targetValue}) ${status}`\n            );\n        }\n    });\n    \n    // Calculate results\n    const avgRelativeError = errorCount > 0 ? totalError / errorCount : 0;\n    const success = avgRelativeError <= tolerance;\n    const accuracy = Math.max(0, 100 * (1 - avgRelativeError));\n    \n    return {\n        success,\n        accuracy: Math.round(accuracy),\n        avgRelativeError,\n        parameters: params,\n        target: target,\n        details: details\n    };\n}"
    },
    
    "animation_cleanup": {
      "description": "Animation setup with proper cleanup",
      "code": "startAnimation() {\n    // Cancel existing animation\n    if (this.animationId) {\n        cancelAnimationFrame(this.animationId);\n    }\n    \n    const animate = () => {\n        ${1:// Animation logic}\n        \n        // Continue animation if needed\n        if (${2:shouldContinue}) {\n            this.animationId = requestAnimationFrame(animate);\n        } else {\n            ${3:// Animation complete}\n            this.animationId = null;\n        }\n    };\n    \n    this.animationId = requestAnimationFrame(animate);\n}\n\nstopAnimation() {\n    if (this.animationId) {\n        cancelAnimationFrame(this.animationId);\n        this.animationId = null;\n    }\n}\n\n// In cleanup/teardown method\nasync onTeardown() {\n    this.stopAnimation();\n    \n    // Clear intervals\n    if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n    }\n    \n    // Clear timeouts\n    if (this.delayTimeout) {\n        clearTimeout(this.delayTimeout);\n    }\n    \n    await super.onTeardown();\n}"
    },
    
    "error_boundary": {
      "description": "Error boundary pattern with fallback UI",
      "code": "async ${1:methodName}() {\n    try {\n        ${2:// Main logic}\n        \n    } catch (error) {\n        console.error('${3:Operation} failed:', error);\n        \n        // Show user-friendly error\n        this.showError(\n            '${4:User-friendly error message}', \n            { duration: 5000 }\n        );\n        \n        // Optional: Show fallback UI\n        this.showFallbackUI();\n        \n        // Re-throw if needed\n        throw error;\n    }\n}\n\nshowFallbackUI() {\n    const container = this.container || document.getElementById('app');\n    if (container) {\n        container.innerHTML = `\n            <div class=\"error-fallback\" style=\"padding: 40px; text-align: center;\">\n                <h3>‚ö†Ô∏è ${5:Something went wrong}</h3>\n                <p>${6:Fallback message}</p>\n                <button onclick=\"${7:location.reload()}\" \n                        style=\"padding: 10px 20px; margin-top: 20px;\">\n                    ${8:üîÑ Try Again}\n                </button>\n            </div>\n        `;\n    }\n}"
    },
    
    "level_file_template": {
      "description": "Complete level file template with all standard components",
      "code": "/**\n * ${1:Level Name}\n * \n * ${2:Level description}\n * \n * @fileoverview ${3:Level type} level implementation\n * @author ${4:Your Name}\n * @version 1.0.0\n * @type ${5:interactive}\n */\n\n// Dependency checks\nif (typeof ${6:InteractiveLevelTemplate} === 'undefined') {\n    console.error('${6:InteractiveLevelTemplate} not loaded');\n}\n\nif (typeof GradientDescentService === 'undefined') {\n    console.warn('GradientDescentService not available');\n}\n\nif (typeof LevelProgressStore === 'undefined') {\n    console.warn('State management not available');\n}\n\n/**\n * ${1:Level Name} Implementation\n */\nclass ${7:LevelClassName}Level extends ${6:InteractiveLevelTemplate} {\n    \n    constructor() {\n        super({\n            id: '${8:level-id}',\n            name: '${1:Level Name}',\n            type: '${5:interactive}',\n            description: '${2:Level description}',\n            \n            ${9:// Level-specific configuration}\n            \n            trackProgress: true,\n            debug: false\n        });\n    }\n    \n    async setup() {\n        await super.setup();\n        ${10:// Custom setup}\n        this.log('${1:Level Name} setup complete');\n    }\n    \n    ${11:// Custom methods}\n    \n    async onTeardown() {\n        ${12:// Custom cleanup}\n        await super.onTeardown();\n        this.log('${1:Level Name} cleanup complete');\n    }\n}\n\n/**\n * Creates the ${1:Level Name}\n */\nasync function create${7:LevelClassName}Level() {\n    try {\n        const level = new ${7:LevelClassName}Level();\n        await level.create();\n        window.currentLevel = level;\n        return level;\n    } catch (error) {\n        console.error('Failed to create ${1:Level Name}:', error);\n        // Error UI handling\n        throw error;\n    }\n}\n\n// Exports\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { create${7:LevelClassName}Level };\n} else {\n    window.create${7:LevelClassName}Level = create${7:LevelClassName}Level;\n}"
    },
    
    "dom_manipulation_safe": {
      "description": "Safe DOM manipulation with error handling",
      "code": "// Safe element selection\ngetElement(id) {\n    const element = document.getElementById(id);\n    if (!element) {\n        console.warn(`Element not found: ${id}`);\n        return null;\n    }\n    return element;\n}\n\n// Safe property update\nupdateElement(id, property, value) {\n    const element = this.getElement(id);\n    if (element && property in element) {\n        element[property] = value;\n        return true;\n    }\n    return false;\n}\n\n// Safe text content update\nupdateTextContent(id, content) {\n    const element = this.getElement(id);\n    if (element) {\n        element.textContent = String(content);\n        return true;\n    }\n    return false;\n}\n\n// Safe HTML update (sanitized)\nupdateHTML(id, html) {\n    const element = this.getElement(id);\n    if (element) {\n        // Simple sanitization - remove script tags\n        const sanitized = html.replace(/<script[^>]*>.*?<\\/script>/gi, '');\n        element.innerHTML = sanitized;\n        return true;\n    }\n    return false;\n}\n\n// Safe style update\nupdateStyle(id, styles) {\n    const element = this.getElement(id);\n    if (element) {\n        Object.assign(element.style, styles);\n        return true;\n    }\n    return false;\n}"
    }
  }
}