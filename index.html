<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Optimization Learning Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            text-align: center;
            color: #333;
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .navigation {
            position: fixed;
            top: 100px;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 0;
            z-index: 999;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            padding: 0 20px;
        }

        .nav-btn {
            padding: 12px 20px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .nav-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .nav-btn.locked {
            background: linear-gradient(45deg, #999, #777);
            color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .nav-btn.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(153, 153, 153, 0.3);
        }

        .nav-btn.completed {
            background: linear-gradient(45deg, #2ed573, #1dd1a1);
            box-shadow: 0 4px 15px rgba(45, 213, 115, 0.4);
        }

        .level-goal {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            color: #333;
        }

        .level-goal.completed {
            background: rgba(45, 213, 115, 0.1);
            border: 1px solid rgba(45, 213, 115, 0.3);
            color: #1dd1a1;
        }

        .content-container {
            position: relative;
            margin-top: 180px;
            min-height: calc(100vh - 180px);
            overflow: hidden;
        }

        .content-slider {
            display: flex;
            min-height: calc(100vh - 180px);
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .content-part {
            min-width: 100%;
            min-height: calc(100vh - 180px);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            text-align: center;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .part-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .part-title {
            font-size: 3rem;
            color: #333;
            margin-bottom: 20px;
            font-weight: 300;
        }

        .part-description {
            font-size: 1.2rem;
            color: #666;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .part-details {
            font-size: 1rem;
            color: #888;
            line-height: 1.8;
        }

        .arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            color: #333;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
        }

        .arrow:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .arrow-left {
            left: 30px;
        }

        .arrow-right {
            right: 30px;
        }

        .arrow:disabled {
            opacity: 0;
            pointer-events: none;
        }

        /* Robot-specific styles */
        .robot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            justify-content: flex-start;
            min-height: auto;
        }

        .robot-section {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        .robot-section h3 {
            color: white;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .robot-svg {
            transition: all 0.3s ease;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2));
            width: 200px;
            height: 250px;
            margin: 10px 0;
        }

        .robot-svg:hover {
            transform: scale(1.02);
            filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.3));
        }

        .energy-control {
            margin-top: 20px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }

        .energy-control label {
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
        }

        .energy-control input[type="range"] {
            width: 250px;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .energy-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .energy-control input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .energy-display {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            color: #333;
            font-size: 1.2rem;
        }

        .energy-bar {
            width: 200px;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .optimal-indicator {
            margin-top: 10px;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.7);
            color: #666;
        }

        .optimal-indicator.optimal {
            background: linear-gradient(45deg, #2ed573, #1dd1a1);
            color: white;
            box-shadow: 0 5px 15px rgba(45, 213, 115, 0.4);
        }

        .gradient-btn {
            margin-top: 15px;
            padding: 12px 20px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            margin-right: 10px;
            min-width: 120px;
            white-space: nowrap;
            box-sizing: border-box;
        }

        .reset-btn {
            margin-top: 15px;
            padding: 12px 20px;
            border: none;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            min-width: 120px;
            white-space: nowrap;
            box-sizing: border-box;
        }

        .gradient-btn:hover:not(:disabled), .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .reset-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .gradient-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .step-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            font-size: 12px;
            color: #333;
            line-height: 1.4;
        }

        .potion-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 500px;
        }

        .potion-control {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .potion-control label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            text-align: center;
        }

        .potion-control input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 5px;
        }

        .potion-control .potion-value {
            text-align: center;
            font-weight: bold;
            color: #333;
            font-size: 12px;
        }

        .purple-potion {
            grid-column: 1 / 3;
            justify-self: center;
            max-width: 200px;
        }

        .potion-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .potion-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        /* Money display styling */
        .money-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2ed573;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        /* Disabled button styling */
        .gradient-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Training dogs container */
        .training-dogs {
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
        }

        .training-dogs h4 {
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }

        .dog-grid {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .dog-item {
            text-align: center;
            flex: 1;
            min-width: 90px;
            max-width: 120px;
        }

        .dog-name {
            font-weight: bold;
            font-size: 12px;
            margin-top: 5px;
        }

        .dog-preference {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        /* Robot grid for Level 7 & 9 */
        .robot-grid {
            display: grid;
            grid-template-columns: repeat(40, 1fr);
            gap: 2px;
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .robot-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ddd;
            transition: all 0.3s ease;
            border: 1px solid #bbb;
        }

        .robot-dot.active {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
            border-color: #00aa55;
        }

        .robot-dot.inactive {
            background: #888;
            border-color: #666;
        }

        .prediction-controls {
            text-align: center;
            margin: 20px 0;
        }

        .prediction-stats {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-size: 14px;
        }

        /* Feature robots for Level 8 */
        .feature-robots {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .feature-robot {
            text-align: center;
            flex: 1;
            min-width: 80px;
            max-width: 100px;
        }

        .feature-robot svg {
            width: 60px;
            height: 80px;
            margin-bottom: 8px;
        }

        .robot-features {
            font-size: 10px;
            line-height: 1.2;
            color: #333;
        }

        .feature-function {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .feature-function h4 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .weight-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #667eea;
            margin: 10px 0;
            font-weight: bold;
        }

        .loss-display {
            font-size: 16px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }

        /* Congratulations page styling */
        .congratulations-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            text-align: center;
        }

        .celebration-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .ai-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }

        .ai-example {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .ai-example:hover {
            transform: translateY(-5px);
        }

        .ai-example h4 {
            color: #667eea;
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .ai-example-icon {
            font-size: 2rem;
        }

        .ai-example p {
            color: #555;
            line-height: 1.6;
            font-size: 14px;
        }

        .gradient-explanation {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
        }

        .gradient-explanation h3 {
            color: #667eea;
            font-size: 1.8rem;
            margin-bottom: 20px;
        }

        .gradient-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .gradient-step {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .gradient-step:hover {
            background: #667eea;
            color: white;
        }

        .gradient-arrow {
            font-size: 2rem;
            color: #667eea;
            font-weight: bold;
        }

        .disabled-btn {
            background: linear-gradient(45deg, #999, #777) !important;
            color: #ccc !important;
            cursor: not-allowed !important;
            opacity: 0.6;
            margin-top: 30px;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            position: relative;
        }

        .disabled-btn:hover {
            transform: none !important;
            box-shadow: 0 4px 15px rgba(153, 153, 153, 0.3) !important;
        }

        .journey-summary {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
            text-align: left;
        }

        .journey-summary h3 {
            text-align: center;
            color: #667eea;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        .journey-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .journey-step {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .journey-step-number {
            color: #667eea;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .journey-step-title {
            font-weight: bold;
            color: #333;
            margin: 5px 0;
            font-size: 0.95rem;
        }

        .journey-step-desc {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .nav-buttons {
                gap: 5px;
            }
            
            .nav-btn {
                padding: 10px 15px;
                font-size: 12px;
            }
            
            .part-title {
                font-size: 2rem;
            }
            
            .part-content {
                padding: 20px;
                margin: 0 10px;
            }
            
            .arrow {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .arrow-left {
                left: 15px;
            }
            
            .arrow-right {
                right: 15px;
            }
            
            .robot-svg {
                width: 160px;
                height: 200px;
            }
            
            .energy-control {
                padding: 15px;
                min-width: 250px;
            }
            
            .energy-control input[type="range"] {
                width: 200px;
            }
            
            .energy-bar {
                width: 150px;
            }

            .potion-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .potion-control label {
                font-size: 12px;
            }
            
            .robot-svg {
                width: 140px;
                height: 175px;
            }

            .robot-grid {
                grid-template-columns: repeat(25, 1fr);
                max-width: 400px;
            }
            
            .robot-dot {
                width: 10px;
                height: 10px;
            }
            
            .feature-robots {
                gap: 5px;
                padding: 10px;
            }
            
            .feature-robot {
                min-width: 60px;
            }
            
            .feature-robot svg {
                width: 45px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>AI Optimization Learning Journey</h1>
    </header>

    <nav class="navigation">
        <div class="nav-buttons" id="navButtons">
            <!-- Navigation buttons will be generated by JavaScript -->
        </div>
    </nav>

    <main class="content-container">
        <div class="content-slider" id="contentSlider">
            <!-- Content parts will be generated by JavaScript -->
        </div>
    </main>

    <button class="arrow arrow-left" id="prevBtn">‹</button>
    <button class="arrow arrow-right" id="nextBtn">›</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script>
        // Modular Gradient Descent System for future extensibility
        class OptimizationEngine {
            constructor(learningRate = 0.1) {
                this.learningRate = learningRate;
                this.history = [];
            }

            // Generic loss function - can be overridden for different scenarios
            calculateLoss(variables, targets) {
                // Default: Mean Squared Error for multiple variables
                let totalLoss = 0;
                for (let i = 0; i < variables.length; i++) {
                    totalLoss += Math.pow(variables[i] - targets[i], 2);
                }
                return totalLoss / variables.length;
            }

            // Calculate gradients using TensorFlow.js
            calculateGradients(variables, targets) {
                const variableTensors = variables.map(v => tf.scalar(v));
                const targetTensors = targets.map(t => tf.scalar(t));
                
                // Calculate gradients for each variable
                const gradients = [];
                for (let i = 0; i < variables.length; i++) {
                    // Gradient of MSE: 2 * (variable - target) / num_variables
                    const gradient = tf.mul(
                        tf.scalar(2 / variables.length),
                        tf.sub(variableTensors[i], targetTensors[i])
                    );
                    gradients.push(gradient.dataSync()[0]);
                }

                // Clean up tensors
                variableTensors.forEach(t => t.dispose());
                targetTensors.forEach(t => t.dispose());

                return gradients;
            }

            // Perform one optimization step
            optimizationStep(variables, targets, constraints = null) {
                const loss = this.calculateLoss(variables, targets);
                const gradients = this.calculateGradients(variables, targets);
                
                // Update variables
                const newVariables = variables.map((variable, i) => {
                    let rawStep = this.learningRate * gradients[i];
                    let newValue = variable - rawStep;
                    
                    // Apply constraints if provided
                    if (constraints && constraints[i]) {
                        const { min, max } = constraints[i];
                        newValue = Math.max(min, Math.min(max, newValue));
                    }
                    
                    let roundedValue = Math.round(newValue);
                    
                    // Fix for getting stuck due to rounding: if rounded value equals current
                    // but we haven't reached target, force a minimum step of 1 in correct direction
                    if (roundedValue === variable && variable !== targets[i]) {
                        const direction = targets[i] > variable ? 1 : -1;
                        roundedValue = variable + direction;
                        
                        // Still respect constraints
                        if (constraints && constraints[i]) {
                            const { min, max } = constraints[i];
                            roundedValue = Math.max(min, Math.min(max, roundedValue));
                        }
                    }
                    
                    return roundedValue;
                });

                // Store history for analysis with more detailed step info
                const stepInfo = {
                    step: this.history.length,
                    variables: [...variables],
                    targets: [...targets],
                    loss: loss,
                    gradients: [...gradients],
                    rawSteps: gradients.map(g => this.learningRate * g),
                    newVariables: [...newVariables]
                };
                
                this.history.push(stepInfo);

                return {
                    loss,
                    gradients,
                    rawSteps: stepInfo.rawSteps,
                    newVariables,
                    converged: this.checkConvergence(newVariables, targets)
                };
            }

            // Check if optimization has converged (exact match required)
            checkConvergence(variables, targets, tolerance = 0) {
                for (let i = 0; i < variables.length; i++) {
                    if (Math.abs(variables[i] - targets[i]) > tolerance) {
                        return false;
                    }
                }
                return true;
            }

            // Reset optimization history
            reset() {
                this.history = [];
            }
        }

        // Level-based Configuration with Completion Requirements
        const levels = [
            {
                title: "Energy Control",
                description: "Power up the robot by adjusting its energy level. Find the optimal point to activate its systems!",
                details: "The robot responds to different energy levels. Watch its eyes light up when you hit the perfect energy setting.",
                goal: "Find the optimal energy level to activate the robot's systems!"
            },
            {
                title: "Potion Brewing",
                description: "Help the witch create the perfect magical brew by balancing yellow and blue potions.",
                details: "Mix the right amounts of each potion to transform the murky brew into a glowing green elixir!",
                goal: "Create the perfect magical brew with yellow and blue essences!"
            },
            {
                title: "AI Optimization",
                description: "Watch the robot learn to find its optimal energy level using gradient descent!",
                details: "Use artificial intelligence to automatically optimize the robot's energy. The AI will calculate the loss and adjust the energy step by step.",
                goal: "Use AI gradient descent to automatically find the optimal energy level!"
            },
            {
                title: "Multi-Potion Mastery",
                description: "Master the art of 5-ingredient potion brewing! Use AI to find the perfect balance of all magical essences.",
                details: "Control red, yellow, green, blue, and purple essences. Watch the AI optimize all ingredients simultaneously using multi-variable gradient descent!",
                goal: "Perfect all 5 magical essences using multi-variable optimization!"
            },
            {
                title: "Real-World Challenge",
                description: "Try to buy the perfect bone for Max without knowing his preference!",
                details: "Experience the challenge of optimization without training data - just like real-world problems!",
                goal: "Purchase a bone for Max (any size) to complete this challenge!"
            },
            {
                title: "Training Data Power",
                description: "Use training data to make better decisions for Max's second bone!",
                details: "See how machine learning training data helps make better predictions in real scenarios.",
                goal: "Use the training data to buy Max a better bone!"
            },
            {
                title: "Large Scale Prediction",
                description: "Apply your basic model to 1000 robots - see how it performs without proper training!",
                details: "Experience the reality of applying simple models to large datasets. Watch how basic predictions perform on real-world scale problems.",
                goal: "Use the basic prediction model on 1000 robots!"
            },
            {
                title: "Feature Engineering",
                description: "Learn to identify which robot features matter most for accurate predictions!",
                details: "Analyze 10 robots with different heights, head sizes, and eye glow. Use gradient descent to find the optimal feature weights.",
                goal: "Optimize the feature weights A, B, and C to minimize prediction loss!"
            },
            {
                title: "Improved Predictions",
                description: "Apply your optimized model to 1000 robots and see the dramatic improvement!",
                details: "Experience the power of proper feature engineering and model optimization. See how training on the right features transforms prediction accuracy.",
                goal: "Use the improved prediction model on 1000 robots!"
            },
            {
                title: "Congratulations!",
                description: "You've mastered AI optimization! See how gradient descent powers the world's most advanced AI systems.",
                details: "From ChatGPT to self-driving cars, every major AI breakthrough uses the same fundamental principle you just learned.",
                goal: "Celebrate your journey through the fundamentals of AI optimization!"
            }
        ];

        // Level completion tracking
        let levelCompletions = {
            level1: false,  // Energy Control - find optimal energy (75%)
            level2: false,  // Potion Brewing - perfect brew (yellow=60%, blue=40%)
            level3: false,  // AI Optimization - gradient descent convergence to 75%
            level4: false,  // Multi-Potion - all 5 essences optimal
            level5: false,  // Dog Bone Blind - buy any bone
            level6: false,  // Dog Bone Training - buy second bone
            level7: false,  // Large Scale Prediction - use basic prediction
            level8: false,  // Feature Engineering - optimize A, B, C weights
            level9: false,  // Improved Predictions - use optimized prediction
            level10: false  // Congratulations - always unlocked after level 9
        };

        let currentLevel = 0;
        const OPTIMAL_ENERGY = 75; // Optimal energy level for robot activation (Level 1)
        const OPTIMAL_ENERGY_AI = 90; // Different optimal energy level for AI robot (Level 3)
        const OPTIMAL_YELLOW = 60; // Optimal yellow potion level
        const OPTIMAL_BLUE = 40; // Optimal blue potion level
        const LEARNING_RATE = 0.1; // Learning rate for gradient descent
        
        // Multi-potion optimal values for Level 4
        const OPTIMAL_RED = 70;
        const OPTIMAL_YELLOW_MULTI = 60;
        const OPTIMAL_GREEN = 50;
        const OPTIMAL_BLUE_MULTI = 40;
        const OPTIMAL_PURPLE = 30;

        // Dog bone scenario variables
        let userMoney = 10;
        let trueBoneSize = null; // Will be set after user's first guess
        let userFirstGuess = null;
        let dogBonesPurchased = 0;

        // Large scale prediction variables (Levels 7 & 9)
        let robotGridStates = Array(1000).fill(false); // Track which robots are "on"
        let predictionUsed7 = false;
        let predictionUsed9 = false;

        // Feature learning variables (Level 8)
        let featureWeights = { A: 0.5, B: 0.3, C: 0.2 }; // Initial weights for height, head_size, eye_glow
        let featureOptimizer = null; // Will be initialized when needed
        let featureData = []; // Training data for 10 robots
        let currentLoss = 0;

        // Level completion checking functions
        function checkLevel1Completion() {
            const energySlider = document.getElementById('energySlider');
            if (energySlider && parseInt(energySlider.value) === OPTIMAL_ENERGY) {
                if (!levelCompletions.level1) {
                    levelCompletions.level1 = true;
                    showLevelCompleteMessage(1, "🎉 Level 1 Complete! You found the optimal energy level!");
                    updateNavigation();
                }
            }
        }

        function checkLevel2Completion() {
            const yellowSlider = document.getElementById('yellowSlider');
            const blueSlider = document.getElementById('blueSlider');
            if (yellowSlider && blueSlider) {
                const yellowLevel = parseInt(yellowSlider.value);
                const blueLevel = parseInt(blueSlider.value);
                if (yellowLevel === OPTIMAL_YELLOW && blueLevel === OPTIMAL_BLUE) {
                    if (!levelCompletions.level2) {
                        levelCompletions.level2 = true;
                        showLevelCompleteMessage(2, "✨ Level 2 Complete! Perfect magical brew achieved!");
                        updateNavigation();
                    }
                }
            }
        }

        function checkLevel3Completion() {
            const energySliderAI = document.getElementById('energySliderAI');
            if (energySliderAI && parseInt(energySliderAI.value) === OPTIMAL_ENERGY_AI) {
                if (!levelCompletions.level3) {
                    levelCompletions.level3 = true;
                    showLevelCompleteMessage(3, "🤖 Level 3 Complete! AI successfully optimized to target!");
                    updateNavigation();
                }
            }
        }

        function checkLevel4Completion() {
            const sliders = {
                red: document.getElementById('redSliderMulti'),
                yellow: document.getElementById('yellowSliderMulti'),
                green: document.getElementById('greenSliderMulti'),
                blue: document.getElementById('blueSliderMulti'),
                purple: document.getElementById('purpleSliderMulti')
            };
            
            if (Object.values(sliders).every(slider => slider)) {
                const levels = {
                    red: parseInt(sliders.red.value),
                    yellow: parseInt(sliders.yellow.value),
                    green: parseInt(sliders.green.value),
                    blue: parseInt(sliders.blue.value),
                    purple: parseInt(sliders.purple.value)
                };
                
                const optimalValues = {
                    red: OPTIMAL_RED,
                    yellow: OPTIMAL_YELLOW_MULTI,
                    green: OPTIMAL_GREEN,
                    blue: OPTIMAL_BLUE_MULTI,
                    purple: OPTIMAL_PURPLE
                };
                
                const isPerfect = Object.keys(levels).every(color => 
                    levels[color] === optimalValues[color]
                );
                
                if (isPerfect && !levelCompletions.level4) {
                    levelCompletions.level4 = true;
                    showLevelCompleteMessage(4, "🌟 Level 4 Complete! Master alchemist achievement unlocked!");
                    updateNavigation();
                }
            }
        }

        function checkLevel5Completion() {
            // Level 5 completes when any bone is purchased
            if (dogBonesPurchased > 0 && !levelCompletions.level5) {
                levelCompletions.level5 = true;
                showLevelCompleteMessage(5, "🦴 Level 5 Complete! You experienced the challenge of blind optimization!");
                
                // Generate training data for Level 6 after a short delay
                setTimeout(() => {
                    generateTrainingDogs();
                    updateNavigation(); // Update navigation after training data is ready
                }, 1500); // 1.5 second delay for realism
                
                updateNavigation();
            }
        }

        function checkLevel6Completion() {
            // Level 6 completes when second bone is purchased
            if (dogBonesPurchased > 1 && !levelCompletions.level6) {
                levelCompletions.level6 = true;
                showLevelCompleteMessage(6, "🎓 Level 6 Complete! You've mastered the power of training data!");
                updateNavigation();
            }
        }

        function checkLevel7Completion() {
            // Level 7 completes when prediction is used
            if (predictionUsed7 && !levelCompletions.level7) {
                levelCompletions.level7 = true;
                showLevelCompleteMessage(7, "📊 Level 7 Complete! You've seen how basic predictions perform at scale!");
                updateNavigation();
            }
        }

        function checkLevel8Completion() {
            // Level 8 completes when loss is minimized (below threshold)
            if (currentLoss < 5.0 && !levelCompletions.level8) {
                levelCompletions.level8 = true;
                showLevelCompleteMessage(8, "🔬 Level 8 Complete! You've mastered feature engineering!");
                updateNavigation();
            }
        }

        function checkLevel9Completion() {
            // Level 9 completes when improved prediction is used
            if (predictionUsed9 && !levelCompletions.level9) {
                levelCompletions.level9 = true;
                showLevelCompleteMessage(9, "🏆 Level 9 Complete! You've witnessed the power of optimized models!");
                
                // Auto-unlock Level 10 (Congratulations page)
                setTimeout(() => {
                    levelCompletions.level10 = true;
                    updateNavigation();
                }, 1000);
                
                updateNavigation();
            }
        }

        function showLevelCompleteMessage(levelNum, message) {
            // Create a temporary celebration message
            const celebration = document.createElement('div');
            celebration.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #2ed573, #1dd1a1);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 10px 30px rgba(45, 213, 115, 0.5);
                z-index: 10000;
                text-align: center;
                animation: celebration 0.6s ease-out;
            `;
            celebration.innerHTML = message;
            
            // Add animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes celebration {
                    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(celebration);
            
            // Update the level goal styling
            const levelGoal = document.querySelector('.level-goal');
            if (levelGoal) {
                levelGoal.classList.add('completed');
                levelGoal.innerHTML = `✅ <strong>COMPLETED:</strong> ${levels[levelNum - 1].goal}`;
            }
            
            // Remove after 3 seconds
            setTimeout(() => {
                celebration.remove();
                style.remove();
            }, 3000);
        }

        function isLevelUnlocked(levelIndex) {
            if (levelIndex === 0) return true; // Level 1 is always unlocked
            
            // Check if previous level is completed
            const completionKeys = ['level1', 'level2', 'level3', 'level4', 'level5', 'level6', 'level7', 'level8', 'level9'];
            const previousCompleted = levelCompletions[completionKeys[levelIndex - 1]];
            
            // Special check for Level 6 (index 5) - also needs training data to be generated
            if (levelIndex === 5) { // Level 6 (0-indexed)
                return previousCompleted && trueBoneSize !== null;
            }
            
            return previousCompleted;
        }

        // Initialize optimization engine after constants are defined
        const optimizer = new OptimizationEngine(LEARNING_RATE);

        // Setup energy control functionality
        function setupEnergyControl() {
            const energySlider = document.getElementById('energySlider');
            const energyValue = document.getElementById('energyValue');
            const energyFill = document.getElementById('energyFill');
            const optimalIndicator = document.getElementById('optimalIndicator');
            
            if (energySlider && energyValue && energyFill && optimalIndicator) {
                energySlider.addEventListener('input', function(e) {
                    const energy = parseInt(e.target.value);
                    updateRobotEnergy(energy);
                });
                // Initialize robot energy
                updateRobotEnergy(parseInt(energySlider.value));
            }

            // Setup potion controls for Level 2
            const yellowSlider = document.getElementById('yellowSlider');
            const blueSlider = document.getElementById('blueSlider');
            
            if (yellowSlider && blueSlider) {
                yellowSlider.addEventListener('input', function(e) {
                    updatePotionBrew();
                });
                blueSlider.addEventListener('input', function(e) {
                    updatePotionBrew();
                });
                // Initialize potion brew
                updatePotionBrew();
            }

            // Setup AI optimization controls for Level 3
            const energySliderAI = document.getElementById('energySliderAI');
            const gradientDescentBtn = document.getElementById('gradientDescentBtn');
            const resetOptimizationBtn = document.getElementById('resetOptimizationBtn');
            
            if (energySliderAI && gradientDescentBtn) {
                energySliderAI.addEventListener('input', function(e) {
                    const energy = parseInt(e.target.value);
                    updateRobotEnergyAI(energy);
                });
                
                gradientDescentBtn.addEventListener('click', function() {
                    performGradientDescentStep();
                });
                
                if (resetOptimizationBtn) {
                    resetOptimizationBtn.addEventListener('click', function() {
                        resetOptimization();
                    });
                }
                
                // Initialize AI robot energy
                updateRobotEnergyAI(parseInt(energySliderAI.value));
            }

            // Setup multi-potion controls for Level 4
            const potionSliders = ['red', 'yellow', 'green', 'blue', 'purple'].map(color => 
                document.getElementById(`${color}SliderMulti`)
            );
            const gradientDescentMultiBtn = document.getElementById('gradientDescentMultiBtn');
            const resetMultiBtn = document.getElementById('resetMultiBtn');
            
            if (potionSliders.every(slider => slider) && gradientDescentMultiBtn) {
                // Add listeners to all potion sliders
                potionSliders.forEach(slider => {
                    slider.addEventListener('input', function(e) {
                        updateMultiPotionBrew();
                    });
                });
                
                gradientDescentMultiBtn.addEventListener('click', function() {
                    performMultiPotionOptimization();
                });
                
                if (resetMultiBtn) {
                    resetMultiBtn.addEventListener('click', function() {
                        resetMultiPotionOptimization();
                    });
                }
                
                // Initialize multi-potion brew
                updateMultiPotionBrew();
            }

            // Setup dog bone controls for Level 5
            const boneSizeSlider = document.getElementById('boneSizeSlider');
            const buyBoneBtn = document.getElementById('buyBoneBtn');
            const gradientDescentDisabledBtn = document.getElementById('gradientDescentDisabledBtn');
            
            if (boneSizeSlider && buyBoneBtn) {
                boneSizeSlider.addEventListener('input', function(e) {
                    updateBoneDisplay();
                });
                
                buyBoneBtn.addEventListener('click', function() {
                    buyBoneForDog();
                });
                
                // Add hover tooltip for disabled gradient descent button
                if (gradientDescentDisabledBtn) {
                    gradientDescentDisabledBtn.addEventListener('mouseenter', function() {
                        showTooltip(gradientDescentDisabledBtn, "Gradient descent only works when we know the right answer!");
                    });
                    
                    gradientDescentDisabledBtn.addEventListener('mouseleave', function() {
                        hideTooltip();
                    });
                }
                
                // Initialize bone display
                updateBoneDisplay();
                updateMoneyDisplay();
            }

            // Setup dog bone controls for Level 6 (with training data)
            const boneSizeSliderPart6 = document.getElementById('boneSizeSliderPart6');
            const buyBoneBtn2 = document.getElementById('buyBoneBtn2');
            
            if (boneSizeSliderPart6 && buyBoneBtn2) {
                boneSizeSliderPart6.addEventListener('input', function(e) {
                    updateBoneDisplayPart6();
                });
                
                buyBoneBtn2.addEventListener('click', function() {
                    buySecondBone();
                });
                
                // Initialize part 6 display (training data will be generated when Level 5 completes)
                updateBoneDisplayPart6();
                
                // If training data exists, generate it immediately (for page refreshes, etc.)
                if (trueBoneSize) {
                    generateTrainingDogs();
                }
            }

            // Setup Level 7 controls - Large Scale Prediction (Bad)
            const usePredictionBtn7 = document.getElementById('usePredictionBtn7');
            const robotGrid7 = document.getElementById('robotGrid7');
            
            if (usePredictionBtn7 && robotGrid7) {
                // Create robot grid
                createRobotGrid(robotGrid7);
                
                usePredictionBtn7.addEventListener('click', function() {
                    useBadPrediction();
                });
            }

            // Setup Level 8 controls - Feature Engineering
            const optimizeWeightsBtn = document.getElementById('optimizeWeightsBtn');
            const resetWeightsBtn = document.getElementById('resetWeightsBtn');
            const featureRobotsContainer = document.getElementById('featureRobots');
            
            if (optimizeWeightsBtn && featureRobotsContainer) {
                // Initialize feature learning
                initializeFeatureLearning();
                
                optimizeWeightsBtn.addEventListener('click', function() {
                    optimizeFeatureWeights();
                });
                
                if (resetWeightsBtn) {
                    resetWeightsBtn.addEventListener('click', function() {
                        resetFeatureWeights();
                    });
                }
            }

            // Setup Level 9 controls - Large Scale Prediction (Good)
            const usePredictionBtn9 = document.getElementById('usePredictionBtn9');
            const robotGrid9 = document.getElementById('robotGrid9');
            
            if (usePredictionBtn9 && robotGrid9) {
                // Create robot grid
                createRobotGrid(robotGrid9);
                
                usePredictionBtn9.addEventListener('click', function() {
                    useGoodPrediction();
                });
            }
        }

        // Update robot based on energy level
        function updateRobotEnergy(energy) {
            const energyValue = document.getElementById('energyValue');
            const energyFill = document.getElementById('energyFill');
            const optimalIndicator = document.getElementById('optimalIndicator');
            const leftEye = document.getElementById('leftEye');
            const rightEye = document.getElementById('rightEye');
            const chestLight = document.getElementById('chestLight');
            
            // Update display values
            if (energyValue) energyValue.textContent = energy + '%';
            if (energyFill) energyFill.style.width = energy + '%';
            
            // Update optimal indicator
            if (optimalIndicator) {
                if (energy === OPTIMAL_ENERGY) {
                    optimalIndicator.textContent = '⚡ OPTIMAL ENERGY REACHED! ⚡';
                    optimalIndicator.classList.add('optimal');
                } else {
                    optimalIndicator.textContent = 'Adjusting energy level...';
                    optimalIndicator.classList.remove('optimal');
                }
            }
            
            // Update robot eyes and chest light
            const isOptimal = energy === OPTIMAL_ENERGY;
            const eyeColor = isOptimal ? '#00ff00' : '#333333';
            const chestColor = isOptimal ? '#00ff88' : '#666666';
            
            if (leftEye) leftEye.setAttribute('fill', eyeColor);
            if (rightEye) rightEye.setAttribute('fill', eyeColor);
            if (chestLight) chestLight.setAttribute('fill', chestColor);
            
            // Add glow effect when optimal
            const robot = document.getElementById('robotSvg');
            if (robot) {
                if (isOptimal) {
                    robot.style.filter = 'drop-shadow(0 0 20px #00ff88) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                } else {
                    robot.style.filter = 'drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                }
            }
            
            // Check level 1 completion
            checkLevel1Completion();
        }

        // Update AI robot based on energy level (Level 3)
        function updateRobotEnergyAI(energy) {
            const energyValueAI = document.getElementById('energyValueAI');
            const energyFillAI = document.getElementById('energyFillAI');
            const aiIndicator = document.getElementById('aiIndicator');
            const leftEyeAI = document.getElementById('leftEyeAI');
            const rightEyeAI = document.getElementById('rightEyeAI');
            const chestLightAI = document.getElementById('chestLightAI');
            
            // Update display values
            if (energyValueAI) energyValueAI.textContent = energy + '%';
            if (energyFillAI) energyFillAI.style.width = energy + '%';
            
            // Calculate and display loss
            const loss = Math.pow(energy - OPTIMAL_ENERGY_AI, 2);
            if (aiIndicator) {
                if (energy === OPTIMAL_ENERGY_AI) {
                    aiIndicator.textContent = '🎯 AI FOUND OPTIMAL SOLUTION! 🎯';
                    aiIndicator.classList.add('optimal');
                } else {
                    aiIndicator.textContent = `🤖 Current Loss: ${loss.toFixed(2)} | Target: ${OPTIMAL_ENERGY_AI}%`;
                    aiIndicator.classList.remove('optimal');
                }
            }
            
            // Update robot eyes and chest light
            const isOptimal = energy === OPTIMAL_ENERGY_AI;
            const eyeColor = isOptimal ? '#00ff00' : '#333333';
            const chestColor = isOptimal ? '#00ff88' : '#666666';
            
            if (leftEyeAI) leftEyeAI.setAttribute('fill', eyeColor);
            if (rightEyeAI) rightEyeAI.setAttribute('fill', eyeColor);
            if (chestLightAI) chestLightAI.setAttribute('fill', chestColor);
            
            // Add glow effect when optimal
            const robotAI = document.getElementById('robotSvgAI');
            if (robotAI) {
                if (isOptimal) {
                    robotAI.style.filter = 'drop-shadow(0 0 20px #00ff88) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                } else {
                    robotAI.style.filter = 'drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                }
            }
            
            // Check level 3 completion
            checkLevel3Completion();
        }

        // Update multi-potion brew based on all 5 color levels (Level 4)
        function updateMultiPotionBrew() {
            const sliders = {
                red: document.getElementById('redSliderMulti'),
                yellow: document.getElementById('yellowSliderMulti'),
                green: document.getElementById('greenSliderMulti'),
                blue: document.getElementById('blueSliderMulti'),
                purple: document.getElementById('purpleSliderMulti')
            };
            
            const values = {
                red: document.getElementById('redValueMulti'),
                yellow: document.getElementById('yellowValueMulti'),
                green: document.getElementById('greenValueMulti'),
                blue: document.getElementById('blueValueMulti'),
                purple: document.getElementById('purpleValueMulti')
            };
            
            const cauldronBrewMulti = document.getElementById('cauldronBrewMulti');
            const multiBrewIndicator = document.getElementById('multiBrewIndicator');
            const witchSvgMulti = document.getElementById('witchSvgMulti');
            
            if (!Object.values(sliders).every(slider => slider)) return;
            
            // Get all current levels
            const levels = {
                red: parseInt(sliders.red.value),
                yellow: parseInt(sliders.yellow.value),
                green: parseInt(sliders.green.value),
                blue: parseInt(sliders.blue.value),
                purple: parseInt(sliders.purple.value)
            };
            
            const optimalValues = {
                red: OPTIMAL_RED,
                yellow: OPTIMAL_YELLOW_MULTI,
                green: OPTIMAL_GREEN,
                blue: OPTIMAL_BLUE_MULTI,
                purple: OPTIMAL_PURPLE
            };
            
            // Update display values
            Object.keys(levels).forEach(color => {
                if (values[color]) {
                    values[color].textContent = levels[color] + '%';
                }
            });
            
            // Calculate optimality for each color (0-1 scale)
            const optimalities = {};
            let totalOptimality = 0;
            Object.keys(levels).forEach(color => {
                const distance = Math.abs(levels[color] - optimalValues[color]);
                const maxDistance = 50; // Maximum possible distance
                optimalities[color] = Math.max(0, 1 - (distance / maxDistance));
                totalOptimality += optimalities[color];
            });
            
            // Overall brew quality (average of all optimalities)
            const brewQuality = totalOptimality / 5;
            
            // Color transition from murky brown to brilliant magical green
            const brownR = 101, brownG = 67, brownB = 33; // Murky brown #654321
            const magicR = 50, magicG = 255, magicB = 150; // Brilliant magical green
            
            const r = Math.round(brownR + (magicR - brownR) * brewQuality);
            const g = Math.round(brownG + (magicG - brownG) * brewQuality);
            const b = Math.round(brownB + (magicB - brownB) * brewQuality);
            
            const brewColor = `rgb(${r}, ${g}, ${b})`;
            
            // Update cauldron brew color
            if (cauldronBrewMulti) {
                cauldronBrewMulti.setAttribute('fill', brewColor);
            }
            
            // Check if all are at optimal values
            const isPerfectBrew = Object.keys(levels).every(color => 
                levels[color] === optimalValues[color]
            );
            
            // Count how many are optimal
            const optimalCount = Object.keys(levels).filter(color => 
                levels[color] === optimalValues[color]
            ).length;
            
            // Update brew indicator
            if (multiBrewIndicator) {
                if (isPerfectBrew) {
                    multiBrewIndicator.textContent = '✨🌟 PERFECT 5-ESSENCE ELIXIR! 🌟✨';
                    multiBrewIndicator.classList.add('optimal');
                } else if (optimalCount >= 3) {
                    multiBrewIndicator.textContent = `🧪 Excellent! ${optimalCount}/5 essences optimal`;
                    multiBrewIndicator.classList.remove('optimal');
                } else if (optimalCount >= 1) {
                    multiBrewIndicator.textContent = `⚗️ Progress: ${optimalCount}/5 essences optimal`;
                    multiBrewIndicator.classList.remove('optimal');
                } else {
                    const totalLoss = Object.keys(levels).reduce((sum, color) => {
                        return sum + Math.pow(levels[color] - optimalValues[color], 2);
                    }, 0);
                    multiBrewIndicator.textContent = `🔬 Total Loss: ${totalLoss.toFixed(1)} | Quality: ${(brewQuality * 100).toFixed(1)}%`;
                    multiBrewIndicator.classList.remove('optimal');
                }
            }
            
            // Add glow effect when perfect
            if (witchSvgMulti) {
                if (isPerfectBrew) {
                    witchSvgMulti.style.filter = 'drop-shadow(0 0 30px #32ff96) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                } else if (brewQuality > 0.8) {
                    witchSvgMulti.style.filter = 'drop-shadow(0 0 15px #32ff96) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                } else {
                    witchSvgMulti.style.filter = 'drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                }
            }
            
            // Check level 4 completion
            checkLevel4Completion();
        }

        // Perform multi-variable gradient descent optimization for all 5 potions
        function performMultiPotionOptimization() {
            const sliders = {
                red: document.getElementById('redSliderMulti'),
                yellow: document.getElementById('yellowSliderMulti'),
                green: document.getElementById('greenSliderMulti'),
                blue: document.getElementById('blueSliderMulti'),
                purple: document.getElementById('purpleSliderMulti')
            };
            
            const multiStepInfo = document.getElementById('multiStepInfo');
            
            if (!Object.values(sliders).every(slider => slider)) return;
            
            // Get current values
            const currentValues = [
                parseInt(sliders.red.value),
                parseInt(sliders.yellow.value),
                parseInt(sliders.green.value),
                parseInt(sliders.blue.value),
                parseInt(sliders.purple.value)
            ];
            
            const targetValues = [OPTIMAL_RED, OPTIMAL_YELLOW_MULTI, OPTIMAL_GREEN, OPTIMAL_BLUE_MULTI, OPTIMAL_PURPLE];
            const constraints = Array(5).fill({ min: 0, max: 100 });
            
            // Use optimization engine for multi-variable optimization
            const result = optimizer.optimizationStep(currentValues, targetValues, constraints);
            
            const newValues = result.newVariables;
            
            // Update all sliders
            sliders.red.value = newValues[0];
            sliders.yellow.value = newValues[1];
            sliders.green.value = newValues[2];
            sliders.blue.value = newValues[3];
            sliders.purple.value = newValues[4];
            
            // Update the brew
            updateMultiPotionBrew();
            
            // Display step information
            if (multiStepInfo) {
                const colorNames = ['Red', 'Yellow', 'Green', 'Blue', 'Purple'];
                const changes = newValues.map((newVal, i) => {
                    const change = newVal - currentValues[i];
                    return `${colorNames[i]}: ${currentValues[i]}→${newVal} (${change >= 0 ? '+' : ''}${change})`;
                });
                
                multiStepInfo.innerHTML = `
                    <strong>Multi-Variable Optimization Step ${optimizer.history.length}:</strong><br>
                    Total Loss: ${result.loss.toFixed(3)} | Variables: 5<br>
                    ${changes.join(' | ')}<br>
                    <small>Converged: ${result.converged ? '✅ All Optimal!' : '❌ Optimizing...'}</small>
                `;
            }
            
            // Handle convergence
            const gradientDescentMultiBtn = document.getElementById('gradientDescentMultiBtn');
            if (result.converged && gradientDescentMultiBtn) {
                gradientDescentMultiBtn.disabled = true;
                gradientDescentMultiBtn.textContent = '🌟 Perfect Elixir Achieved!';
                setTimeout(() => {
                    gradientDescentMultiBtn.disabled = false;
                    gradientDescentMultiBtn.textContent = '🧙‍♀️ Multi-Potion Optimization';
                }, 4000);
            }
        }

        // Reset multi-potion optimization
        function resetMultiPotionOptimization() {
            const sliders = {
                red: document.getElementById('redSliderMulti'),
                yellow: document.getElementById('yellowSliderMulti'),
                green: document.getElementById('greenSliderMulti'),
                blue: document.getElementById('blueSliderMulti'),
                purple: document.getElementById('purpleSliderMulti')
            };
            
            const multiStepInfo = document.getElementById('multiStepInfo');
            const gradientDescentMultiBtn = document.getElementById('gradientDescentMultiBtn');
            
            // Reset to random starting points
            Object.values(sliders).forEach(slider => {
                if (slider) {
                    slider.value = Math.floor(Math.random() * 101);
                }
            });
            
            // Update brew with new random values
            updateMultiPotionBrew();
            
            // Reset optimizer history
            optimizer.reset();
            
            // Reset button state
            if (gradientDescentMultiBtn) {
                gradientDescentMultiBtn.disabled = false;
                gradientDescentMultiBtn.textContent = '🧙‍♀️ Multi-Potion Optimization';
            }
            
            // Reset step info
            if (multiStepInfo) {
                const currentValues = Object.values(sliders).map(s => s ? s.value : '?').join('%, ');
                multiStepInfo.innerHTML = `
                    <strong>5-Variable Optimization Ready!</strong><br>
                    Targets: ${OPTIMAL_RED}%, ${OPTIMAL_YELLOW_MULTI}%, ${OPTIMAL_GREEN}%, ${OPTIMAL_BLUE_MULTI}%, ${OPTIMAL_PURPLE}%<br>
                    <small>Starting: ${currentValues}% | Learning Rate: ${LEARNING_RATE}</small>
                `;
            }
        }

        // Dog Bone Functions for Levels 5 & 6
        function updateBoneDisplay() {
            const boneSizeSlider = document.getElementById('boneSizeSlider');
            const boneSizeValue = document.getElementById('boneSizeValue');
            
            if (boneSizeSlider && boneSizeValue) {
                const size = parseInt(boneSizeSlider.value);
                boneSizeValue.textContent = size + ' inches';
            }
        }

        function updateMoneyDisplay() {
            const moneyDisplay = document.getElementById('moneyDisplay');
            if (moneyDisplay) {
                moneyDisplay.textContent = `${userMoney}`;
            }
        }

        function buyBoneForDog() {
            const boneSizeSlider = document.getElementById('boneSizeSlider');
            const buyBoneBtn = document.getElementById('buyBoneBtn');
            const dogFeedback = document.getElementById('dogFeedback');
            
            if (!boneSizeSlider || userMoney < 5) return;
            
            const userGuess = parseInt(boneSizeSlider.value);
            userFirstGuess = userGuess;
            
            // Set true bone size based on user's guess
            if (userGuess <= 20) {
                // If guess was low, true value should be higher
                trueBoneSize = userGuess + Math.floor(Math.random() * 30) + 15; // 15-45 inches higher
            } else if (userGuess >= 80) {
                // If guess was high, true value should be lower  
                trueBoneSize = userGuess - Math.floor(Math.random() * 30) - 15; // 15-45 inches lower
            } else {
                // For middle values, randomly go higher or lower
                const goHigher = Math.random() < 0.5;
                if (goHigher) {
                    trueBoneSize = userGuess + Math.floor(Math.random() * 25) + 10;
                } else {
                    trueBoneSize = userGuess - Math.floor(Math.random() * 25) - 10;
                }
            }
            
            // Ensure trueBoneSize stays in reasonable bounds
            trueBoneSize = Math.max(5, Math.min(95, trueBoneSize));
            
            // Deduct money
            userMoney -= 5;
            updateMoneyDisplay();
            
            // Disable buy button
            buyBoneBtn.disabled = true;
            buyBoneBtn.textContent = '🦴 Bone Purchased';
            
            // Show dog's reaction
            if (dogFeedback) {
                const difference = Math.abs(userGuess - trueBoneSize);
                let reaction;
                if (difference > 30) {
                    reaction = "😞 Max sniffs the bone but walks away sadly. This size is way off!";
                } else if (difference > 15) {
                    reaction = "😐 Max tries the bone but seems uninterested. Not quite right...";
                } else {
                    reaction = "🤔 Max picks up the bone briefly but then drops it. Close, but not perfect.";
                }
                
                dogFeedback.innerHTML = `
                    <strong>Result:</strong><br>
                    ${reaction}<br>
                    <small>You guessed ${userGuess} inches. Max actually prefers ${trueBoneSize} inches!</small><br>
                    <small>💰 You have ${userMoney} left. Can you do better with training data?</small>
                `;
                dogFeedback.style.background = 'rgba(255, 107, 107, 0.1)';
                dogFeedback.style.border = '1px solid rgba(255, 107, 107, 0.3)';
            }
            
            dogBonesPurchased++;
            
            // Check level 5 completion
            checkLevel5Completion();
        }

        function generateTrainingDogs() {
            if (!trueBoneSize) return; // Need the true value from Level 5
            
            const trainingDogsContainer = document.getElementById('trainingDogs');
            if (!trainingDogsContainer) return;
            
            // Show loading state first
            trainingDogsContainer.innerHTML = `
                <div style="text-align: center; color: #666; padding: 20px;">
                    <div style="font-size: 16px; margin-bottom: 10px;">🔄 Analyzing training data...</div>
                    <div style="font-size: 14px;">Learning from other dogs' preferences...</div>
                </div>
            `;
            
            // Generate actual training data after a short delay
            setTimeout(() => {
                const dogNames = ['Buddy', 'Luna', 'Charlie', 'Bella', 'Rocky'];
                const dogColors = ['#8B4513', '#A0522D', '#D2691E', '#CD853F', '#DEB887'];
                
                let trainingHTML = '<h4>🐕 Training Data: Other Dogs\' Preferences</h4>';
                trainingHTML += '<div class="dog-grid">';
                
                const trainingData = [];
                
                for (let i = 0; i < 5; i++) {
                    // Generate bone size around the true value with some deviation
                    const deviation = (Math.random() - 0.5) * 16; // ±8 inches deviation
                    let dogBoneSize = Math.round(trueBoneSize + deviation);
                    dogBoneSize = Math.max(5, Math.min(95, dogBoneSize)); // Keep in bounds
                    
                    trainingData.push(dogBoneSize);
                    
                    trainingHTML += `
                        <div class="dog-item">
                            <svg width="60" height="60" viewBox="0 0 60 60">
                                <!-- Dog body -->
                                <ellipse cx="30" cy="40" rx="18" ry="12" fill="${dogColors[i]}"/>
                                <!-- Dog head -->
                                <circle cx="30" cy="25" r="12" fill="${dogColors[i]}"/>
                                <!-- Dog ears -->
                                <ellipse cx="22" cy="18" rx="4" ry="8" fill="${dogColors[i]}" transform="rotate(-30 22 18)"/>
                                <ellipse cx="38" cy="18" rx="4" ry="8" fill="${dogColors[i]}" transform="rotate(30 38 18)"/>
                                <!-- Dog eyes -->
                                <circle cx="26" cy="22" r="2" fill="black"/>
                                <circle cx="34" cy="22" r="2" fill="black"/>
                                <!-- Dog nose -->
                                <circle cx="30" cy="28" r="1.5" fill="black"/>
                                <!-- Dog mouth -->
                                <path d="M 30 30 Q 28 32 26 30" stroke="black" stroke-width="1" fill="none"/>
                                <path d="M 30 30 Q 32 32 34 30" stroke="black" stroke-width="1" fill="none"/>
                            </svg>
                            <div class="dog-name">${dogNames[i]}</div>
                            <div class="dog-preference">Likes ${dogBoneSize}" bones</div>
                        </div>
                    `;
                }
                
                trainingHTML += '</div>';
                
                // Calculate and show average
                const average = trainingData.reduce((sum, val) => sum + val, 0) / trainingData.length;
                trainingHTML += `
                    <div style="text-align: center; padding: 15px; background: rgba(45, 213, 115, 0.1); border-radius: 10px; margin: 15px 0; font-size: 14px; line-height: 1.4;">
                        <strong>📊 Training Data Analysis:</strong><br>
                        Average preferred bone size: <strong>${average.toFixed(1)} inches</strong><br>
                        <small style="font-size: 12px; color: #666;">Range: ${Math.min(...trainingData)}" - ${Math.max(...trainingData)}" | Your first guess: ${userFirstGuess}"</small>
                    </div>
                `;
                
                trainingDogsContainer.innerHTML = trainingHTML;
            }, 1000); // 1 second delay for the loading effect
        }

        function updateBoneDisplayPart6() {
            const boneSizeSliderPart6 = document.getElementById('boneSizeSliderPart6');
            const boneSizeValuePart6 = document.getElementById('boneSizeValuePart6');
            
            if (boneSizeSliderPart6 && boneSizeValuePart6) {
                const size = parseInt(boneSizeSliderPart6.value);
                boneSizeValuePart6.textContent = size + ' inches';
            }
        }

        function buySecondBone() {
            const boneSizeSliderPart6 = document.getElementById('boneSizeSliderPart6');
            const buyBoneBtn2 = document.getElementById('buyBoneBtn2');
            const dogFeedback2 = document.getElementById('dogFeedback2');
            
            if (!boneSizeSliderPart6 || userMoney < 5) return;
            
            const userGuess2 = parseInt(boneSizeSliderPart6.value);
            
            // Deduct money
            userMoney -= 5;
            updateMoneyDisplay();
            
            // Disable buy button
            buyBoneBtn2.disabled = true;
            buyBoneBtn2.textContent = '🦴 Final Bone Purchased';
            
            // Check if guess is close to true value
            const difference = Math.abs(userGuess2 - trueBoneSize);
            
            if (dogFeedback2) {
                let reaction, success = false;
                if (difference <= 5) {
                    reaction = "🎉 MAX LOVES IT! Perfect size bone - he's wagging his tail like crazy!";
                    success = true;
                } else if (difference <= 10) {
                    reaction = "😊 Great choice! Max is happy with this bone and starts chewing right away!";
                    success = true;
                } else if (difference <= 15) {
                    reaction = "🙂 Not bad! Max accepts the bone and seems content. Pretty good guess!";
                } else {
                    reaction = "😞 Still not quite right. Max is polite but not excited about this bone.";
                }
                
                dogFeedback2.innerHTML = `
                    <strong>Final Result:</strong><br>
                    ${reaction}<br>
                    <small>You guessed ${userGuess2} inches. Max's true preference: ${trueBoneSize} inches (${difference}" off)</small><br>
                    <small>First guess: ${userFirstGuess}" (${Math.abs(userFirstGuess - trueBoneSize)}" off) vs Second guess: ${userGuess2}" (${difference}" off)</small><br>
                    <strong>${success ? '🏆 SUCCESS! Training data helped you succeed!' : '📚 Training data made you much closer!'}</strong>
                `;
                dogFeedback2.style.background = success ? 'rgba(45, 213, 115, 0.1)' : 'rgba(255, 193, 7, 0.1)';
                dogFeedback2.style.border = success ? '1px solid rgba(45, 213, 115, 0.3)' : '1px solid rgba(255, 193, 7, 0.3)';
            }
            
            dogBonesPurchased++;
            
            // Check level 6 completion
            checkLevel6Completion();
        }

        // Level 7 & 9 Functions - Robot Grid Management
        function createRobotGrid(container) {
            container.innerHTML = '';
            // Determine which level this is for based on container ID
            const isLevel9 = container.id === 'robotGrid9';
            const prefix = isLevel9 ? 'robot9-' : 'robot7-';
            
            for (let i = 0; i < 1000; i++) {
                const dot = document.createElement('div');
                dot.className = 'robot-dot';
                dot.id = `${prefix}${i}`;
                container.appendChild(dot);
            }
        }

        function useBadPrediction() {
            const predictionStats = document.getElementById('predictionStats7');
            const usePredictionBtn7 = document.getElementById('usePredictionBtn7');
            
            // Simulate bad prediction - only ~11% activated
            const activatedCount = Math.floor(1000 * 0.11 + Math.random() * 20 - 10); // 100-120 robots
            const activatedIndices = [];
            
            // Randomly select robots to activate
            while (activatedIndices.length < activatedCount) {
                const randomIndex = Math.floor(Math.random() * 1000);
                if (!activatedIndices.includes(randomIndex)) {
                    activatedIndices.push(randomIndex);
                }
            }
            
            // Reset all robots first
            for (let i = 0; i < 1000; i++) {
                const robot = document.getElementById(`robot7-${i}`);
                if (robot) {
                    robot.classList.remove('active', 'inactive');
                    robot.classList.add('inactive');
                    robotGridStates[i] = false;
                }
            }
            
            // Activate selected robots
            activatedIndices.forEach(index => {
                const robot = document.getElementById(`robot7-${index}`);
                if (robot) {
                    robot.classList.remove('inactive');
                    robot.classList.add('active');
                    robotGridStates[index] = true;
                }
            });
            
            // Update stats
            if (predictionStats) {
                predictionStats.innerHTML = `
                    📊 <strong>Basic Prediction Results:</strong><br>
                    Activated: ${activatedCount}/1000 robots (${(activatedCount/10).toFixed(1)}%)<br>
                    <small>❌ Only ${(activatedCount/10).toFixed(1)}% success rate! The model needs better features and training.</small>
                `;
                predictionStats.style.background = 'rgba(255, 107, 107, 0.1)';
                predictionStats.style.border = '1px solid rgba(255, 107, 107, 0.3)';
            }
            
            // Mark prediction as used and disable button
            predictionUsed7 = true;
            if (usePredictionBtn7) {
                usePredictionBtn7.disabled = true;
                usePredictionBtn7.textContent = '✅ Basic Prediction Applied';
            }
            
            // Check completion
            checkLevel7Completion();
        }

        function useGoodPrediction() {
            const predictionStats = document.getElementById('predictionStats9');
            const usePredictionBtn9 = document.getElementById('usePredictionBtn9');
            
            // Simulate good prediction - ~91% activated
            const activatedCount = Math.floor(1000 * 0.91 + Math.random() * 20 - 10); // 900-920 robots
            const activatedIndices = [];
            
            // Randomly select robots to activate (most of them)
            while (activatedIndices.length < activatedCount) {
                const randomIndex = Math.floor(Math.random() * 1000);
                if (!activatedIndices.includes(randomIndex)) {
                    activatedIndices.push(randomIndex);
                }
            }
            
            // Reset all robots first
            for (let i = 0; i < 1000; i++) {
                const robot = document.getElementById(`robot9-${i}`);
                if (robot) {
                    robot.classList.remove('active', 'inactive');
                    robot.classList.add('inactive');
                    robotGridStates[i] = false;
                }
            }
            
            // Activate selected robots
            activatedIndices.forEach(index => {
                const robot = document.getElementById(`robot9-${index}`);
                if (robot) {
                    robot.classList.remove('inactive');
                    robot.classList.add('active');
                    robotGridStates[index] = true;
                }
            });
            
            // Update stats
            if (predictionStats) {
                predictionStats.innerHTML = `
                    🎯 <strong>Optimized Prediction Results:</strong><br>
                    Activated: ${activatedCount}/1000 robots (${(activatedCount/10).toFixed(1)}%)<br>
                    <small>🎉 ${(activatedCount/10).toFixed(1)}% success rate! Feature engineering dramatically improved performance!</small>
                `;
                predictionStats.style.background = 'rgba(45, 213, 115, 0.1)';
                predictionStats.style.border = '1px solid rgba(45, 213, 115, 0.3)';
            }
            
            // Mark prediction as used and disable button
            predictionUsed9 = true;
            if (usePredictionBtn9) {
                usePredictionBtn9.disabled = true;
                usePredictionBtn9.textContent = '🚀 Optimized Prediction Applied';
            }
            
            // Check completion
            checkLevel9Completion();
        }

        // Level 8 Functions - Feature Engineering
        function initializeFeatureLearning() {
            // Initialize optimizer for feature weights
            featureOptimizer = new OptimizationEngine(0.05); // Smaller learning rate for stability
            
            // Generate training data - 10 robots with different features
            featureData = [];
            const robotNames = ['RX-1', 'RX-2', 'RX-3', 'RX-4', 'RX-5', 'RX-6', 'RX-7', 'RX-8', 'RX-9', 'RX-10'];
            
            for (let i = 0; i < 10; i++) {
                const height = Math.random() * 60 + 40; // 40-100
                const headSize = Math.random() * 40 + 20; // 20-60  
                const eyeGlow = Math.random(); // 0-1
                
                // True underlying function (hidden from user): 
                // Energy Required = 0.6 * height + 0.3 * headSize + 0.1 * eyeGlow * 100 + small noise
                const energyRequired = 0.6 * height + 0.3 * headSize + 0.1 * eyeGlow * 100 + (Math.random() - 0.5) * 3;
                
                featureData.push({
                    name: robotNames[i],
                    height: height,
                    headSize: headSize,
                    eyeGlow: eyeGlow,
                    energyRequired: energyRequired
                });
            }
            
            // Create visual robots
            createFeatureRobots();
            
            // Calculate initial loss
            updateLossDisplay();
        }

        function createFeatureRobots() {
            const container = document.getElementById('featureRobots');
            if (!container) return;
            
            container.innerHTML = '';
            
            featureData.forEach((robot, index) => {
                const robotDiv = document.createElement('div');
                robotDiv.className = 'feature-robot';
                
                // Scale values for display
                const heightScale = robot.height / 100; // 0.4 to 1.0
                const headScale = robot.headSize / 60; // 0.33 to 1.0
                const eyeGlowIntensity = Math.floor(robot.eyeGlow * 255);
                const eyeGlowColor = `rgb(${eyeGlowIntensity}, ${eyeGlowIntensity}, ${eyeGlowIntensity})`;
                
                // Calculate current prediction for this robot
                const prediction = featureWeights.A * robot.height + 
                                 featureWeights.B * robot.headSize + 
                                 featureWeights.C * robot.eyeGlow * 100;
                
                robotDiv.innerHTML = `
                    <svg viewBox="0 0 60 80" width="60" height="80">
                        <!-- Robot Head (variable size) -->
                        <rect x="${30 - 15 * headScale}" y="10" width="${30 * headScale}" height="${25 * headScale}" 
                              rx="5" fill="#c0c0c0" stroke="#888" stroke-width="1"/>
                        
                        <!-- Robot Eyes (variable glow) -->
                        <circle cx="${30 - 8 * headScale}" cy="${20}" r="${3 * headScale}" fill="${eyeGlowColor}"/>
                        <circle cx="${30 + 8 * headScale}" cy="${20}" r="${3 * headScale}" fill="${eyeGlowColor}"/>
                        
                        <!-- Robot Body -->
                        <rect x="20" y="35" width="20" height="25" rx="3" fill="#e0e0e0" stroke="#999" stroke-width="1"/>
                        
                        <!-- Robot Legs (variable height) -->
                        <rect x="23" y="60" width="4" height="${15 * heightScale}" rx="2" fill="#c0c0c0" stroke="#888" stroke-width="1"/>
                        <rect x="33" y="60" width="4" height="${15 * heightScale}" rx="2" fill="#c0c0c0" stroke="#888" stroke-width="1"/>
                        
                        <!-- Robot Feet -->
                        <ellipse cx="25" cy="${75 + 15 * (heightScale - 1)}" rx="3" ry="2" fill="#a0a0a0"/>
                        <ellipse cx="35" cy="${75 + 15 * (heightScale - 1)}" rx="3" ry="2" fill="#a0a0a0"/>
                    </svg>
                    <div class="robot-features">
                        <strong>${robot.name}</strong><br>
                        Height: ${robot.height.toFixed(1)}<br>
                        Head: ${robot.headSize.toFixed(1)}<br>
                        Glow: ${(robot.eyeGlow * 100).toFixed(1)}%<br>
                        <span style="color: #ff6b6b; font-weight: bold;">Actual: ${robot.energyRequired.toFixed(1)}</span><br>
                        <span style="color: #667eea; font-weight: bold;">Predicted: ${prediction.toFixed(1)}</span>
                    </div>
                `;
                
                container.appendChild(robotDiv);
            });
        }

        function calculatePredictions() {
            return featureData.map(robot => {
                return featureWeights.A * robot.height + 
                       featureWeights.B * robot.headSize + 
                       featureWeights.C * robot.eyeGlow * 100;
            });
        }

        function updateLossDisplay() {
            const predictions = calculatePredictions();
            const trueValues = featureData.map(robot => robot.energyRequired);
            
            // Calculate Mean Squared Error
            let totalSquaredError = 0;
            for (let i = 0; i < predictions.length; i++) {
                const error = predictions[i] - trueValues[i];
                totalSquaredError += error * error;
            }
            currentLoss = totalSquaredError / predictions.length;
            
            // Update displays
            const lossDisplay = document.getElementById('currentLoss');
            if (lossDisplay) {
                lossDisplay.textContent = currentLoss.toFixed(2);
            }
            
            // Update weight displays
            const weightADisplay = document.getElementById('weightA');
            const weightBDisplay = document.getElementById('weightB');
            const weightCDisplay = document.getElementById('weightC');
            
            if (weightADisplay) weightADisplay.textContent = featureWeights.A.toFixed(2);
            if (weightBDisplay) weightBDisplay.textContent = featureWeights.B.toFixed(2);
            if (weightCDisplay) weightCDisplay.textContent = featureWeights.C.toFixed(2);
            
            // Refresh the robot display to show updated predictions
            createFeatureRobots();
            
            // Check for completion
            checkLevel8Completion();
        }

        function optimizeFeatureWeights() {
            const predictions = calculatePredictions();
            const trueValues = featureData.map(robot => robot.energyRequired);
            
            // Calculate gradients manually (partial derivatives of MSE)
            let gradA = 0, gradB = 0, gradC = 0;
            
            for (let i = 0; i < featureData.length; i++) {
                const error = predictions[i] - trueValues[i];
                gradA += 2 * error * featureData[i].height;
                gradB += 2 * error * featureData[i].headSize;
                gradC += 2 * error * featureData[i].eyeGlow * 100;
            }
            
            gradA /= featureData.length;
            gradB /= featureData.length;
            gradC /= featureData.length;
            
            // Much smaller learning rate for stability
            const learningRate = 0.00002; // Very small to prevent oscillations
            
            // Calculate weight updates with bounds
            const deltaA = -learningRate * gradA;
            const deltaB = -learningRate * gradB;
            const deltaC = -learningRate * gradC;
            
            // Limit the size of each update to prevent large jumps
            const maxUpdate = 0.005;
            const clampedDeltaA = Math.max(-maxUpdate, Math.min(maxUpdate, deltaA));
            const clampedDeltaB = Math.max(-maxUpdate, Math.min(maxUpdate, deltaB));
            const clampedDeltaC = Math.max(-maxUpdate, Math.min(maxUpdate, deltaC));
            
            // Update weights using gradient descent
            featureWeights.A += clampedDeltaA;
            featureWeights.B += clampedDeltaB;
            featureWeights.C += clampedDeltaC;
            
            // Keep weights in reasonable bounds
            featureWeights.A = Math.max(0.01, Math.min(0.99, featureWeights.A));
            featureWeights.B = Math.max(0.01, Math.min(0.99, featureWeights.B));
            featureWeights.C = Math.max(0.01, Math.min(0.99, featureWeights.C));
            
            // Update displays
            updateLossDisplay();
            
            // Update step info
            const stepInfo = document.getElementById('weightStepInfo');
            if (stepInfo) {
                stepInfo.innerHTML = `
                    <strong>Feature Weight Optimization Step</strong><br>
                    Updates: A${clampedDeltaA >= 0 ? '+' : ''}${clampedDeltaA.toFixed(5)}, B${clampedDeltaB >= 0 ? '+' : ''}${clampedDeltaB.toFixed(5)}, C${clampedDeltaC >= 0 ? '+' : ''}${clampedDeltaC.toFixed(5)}<br>
                    <small>Loss: ${currentLoss.toFixed(2)} | Target weights: A≈0.6, B≈0.3, C≈0.1</small>
                `;
            }
            
            // Handle convergence
            const optimizeBtn = document.getElementById('optimizeWeightsBtn');
            if (currentLoss < 5.0 && optimizeBtn) {
                optimizeBtn.disabled = true;
                optimizeBtn.textContent = '🎯 Optimal Weights Found!';
                setTimeout(() => {
                    optimizeBtn.disabled = false;
                    optimizeBtn.textContent = '🔬 Optimize Weights';
                }, 3000);
            }
        }

        function resetFeatureWeights() {
            // Reset to random starting weights
            featureWeights.A = Math.random() * 0.8 + 0.1; // 0.1 to 0.9
            featureWeights.B = Math.random() * 0.8 + 0.1;
            featureWeights.C = Math.random() * 0.8 + 0.1;
            
            // Reset optimizer
            if (featureOptimizer) {
                featureOptimizer.reset();
            }
            
            // Update displays
            updateLossDisplay();
            
            // Reset step info
            const stepInfo = document.getElementById('weightStepInfo');
            if (stepInfo) {
                stepInfo.innerHTML = `
                    <strong>Feature Weight Optimization - Reset!</strong><br>
                    New random weights: A=${featureWeights.A.toFixed(2)}, B=${featureWeights.B.toFixed(2)}, C=${featureWeights.C.toFixed(2)}<br>
                    <small>Find the optimal combination of features for accurate energy predictions!</small>
                `;
            }
            
            // Re-enable optimization button
            const optimizeBtn = document.getElementById('optimizeWeightsBtn');
            if (optimizeBtn) {
                optimizeBtn.disabled = false;
                optimizeBtn.textContent = '🔬 Optimize Weights';
            }
        }

        // Tooltip functions
        function showTooltip(element, message) {
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            tooltip.innerHTML = message;
            tooltip.style.cssText = `
                position: absolute;
                background: #333;
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            
            document.body.appendChild(tooltip);
            
            const rect = element.getBoundingClientRect();
            tooltip.style.left = (rect.left + rect.width/2 - tooltip.offsetWidth/2) + 'px';
            tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        function resetOptimization() {
            const energySliderAI = document.getElementById('energySliderAI');
            const stepInfo = document.getElementById('stepInfo');
            const gradientDescentBtn = document.getElementById('gradientDescentBtn');
            
            if (energySliderAI) {
                // Reset to a random starting point
                const randomStart = Math.floor(Math.random() * 101);
                energySliderAI.value = randomStart;
                updateRobotEnergyAI(randomStart);
            }
            
            // Reset optimizer history
            optimizer.reset();
            
            // Reset button state
            if (gradientDescentBtn) {
                gradientDescentBtn.disabled = false;
                gradientDescentBtn.textContent = '🤖 Gradient Descent Step';
            }
            
            // Reset step info
            if (stepInfo) {
                const startValue = energySliderAI ? energySliderAI.value : 'unknown';
                const distance = Math.abs(parseInt(startValue) - OPTIMAL_ENERGY_AI);
                stepInfo.innerHTML = `
                    <strong>Optimization Engine - Ready!</strong><br>
                    Starting: ${startValue}% | Target: ${OPTIMAL_ENERGY_AI}% | Distance: ${distance}<br>
                    <small>Learning Rate: ${LEARNING_RATE} | Will force steps when stuck by rounding</small>
                `;
            }
        }

        function performGradientDescentStep() {
            const energySliderAI = document.getElementById('energySliderAI');
            const stepInfo = document.getElementById('stepInfo');
            
            if (!energySliderAI) return;
            
            const currentEnergy = parseInt(energySliderAI.value);
            
            // Use the optimization engine for single-variable optimization
            const variables = [currentEnergy];
            const targets = [OPTIMAL_ENERGY_AI];
            const constraints = [{ min: 0, max: 100 }]; // Energy must be 0-100%
            
            const result = optimizer.optimizationStep(variables, targets, constraints);
            
            const newEnergyValue = result.newVariables[0];
            
            // Display comprehensive step information
            if (stepInfo) {
                stepInfo.innerHTML = `
                    <strong>TensorFlow.js Optimization Step ${optimizer.history.length}:</strong><br>
                    Loss: ${result.loss.toFixed(3)} | Gradient: ${result.gradients[0].toFixed(3)}<br>
                    Step: ${(LEARNING_RATE * result.gradients[0]).toFixed(3)} | New Value: ${newEnergyValue}%<br>
                    <small>Converged: ${result.converged ? '✅ Yes' : '❌ No'}</small>
                `;
            }
            
            // Update slider and robot
            energySliderAI.value = newEnergyValue;
            updateRobotEnergyAI(newEnergyValue);
            
            // Handle convergence
            const gradientDescentBtn = document.getElementById('gradientDescentBtn');
            if (result.converged && gradientDescentBtn) {
                gradientDescentBtn.disabled = true;
                gradientDescentBtn.textContent = '🎯 Optimization Complete!';
                setTimeout(() => {
                    gradientDescentBtn.disabled = false;
                    gradientDescentBtn.textContent = '🤖 Gradient Descent Step';
                }, 3000);
            }
        }

        // Update potion brew based on yellow and blue potion levels
        function updatePotionBrew() {
            const yellowSlider = document.getElementById('yellowSlider');
            const blueSlider = document.getElementById('blueSlider');
            const yellowValue = document.getElementById('yellowValue');
            const blueValue = document.getElementById('blueValue');
            const cauldronBrew = document.getElementById('cauldronBrew');
            const brewIndicator = document.getElementById('brewIndicator');
            const witchSvg = document.getElementById('witchSvg');
            
            if (!yellowSlider || !blueSlider) return;
            
            const yellowLevel = parseInt(yellowSlider.value);
            const blueLevel = parseInt(blueSlider.value);
            
            // Update display values
            if (yellowValue) yellowValue.textContent = yellowLevel + '%';
            if (blueValue) blueValue.textContent = blueLevel + '%';
            
            // Calculate how close each value is to optimal (0-1 scale)
            const yellowDistance = Math.abs(yellowLevel - OPTIMAL_YELLOW);
            const blueDistance = Math.abs(blueLevel - OPTIMAL_BLUE);
            const maxDistance = 50; // Maximum possible distance from optimal
            
            const yellowOptimality = Math.max(0, 1 - (yellowDistance / maxDistance));
            const blueOptimality = Math.max(0, 1 - (blueDistance / maxDistance));
            
            // Overall brew quality (average of both optimalities)
            const brewQuality = (yellowOptimality + blueOptimality) / 2;
            
            // Color transition from murky brown to bright green
            const brownR = 101, brownG = 67, brownB = 33; // Murky brown #654321
            const greenR = 50, greenG = 205, greenB = 50; // Bright green #32cd32
            
            const r = Math.round(brownR + (greenR - brownR) * brewQuality);
            const g = Math.round(brownG + (greenG - brownG) * brewQuality);
            const b = Math.round(brownB + (greenB - brownB) * brewQuality);
            
            const brewColor = `rgb(${r}, ${g}, ${b})`;
            
            // Update cauldron brew color
            if (cauldronBrew) {
                cauldronBrew.setAttribute('fill', brewColor);
            }
            
            // Check if both are at optimal values
            const isPerfectBrew = (yellowLevel === OPTIMAL_YELLOW && blueLevel === OPTIMAL_BLUE);
            
            // Update brew indicator
            if (brewIndicator) {
                if (isPerfectBrew) {
                    brewIndicator.textContent = '✨ PERFECT MAGICAL BREW! ✨';
                    brewIndicator.classList.add('optimal');
                } else if (brewQuality > 0.8) {
                    brewIndicator.textContent = '🧪 Excellent brew quality!';
                    brewIndicator.classList.remove('optimal');
                } else if (brewQuality > 0.5) {
                    brewIndicator.textContent = '⚗️ Getting better...';
                    brewIndicator.classList.remove('optimal');
                } else {
                    brewIndicator.textContent = 'Mixing potions...';
                    brewIndicator.classList.remove('optimal');
                }
            }
            
            // Add glow effect when perfect
            if (witchSvg) {
                if (isPerfectBrew) {
                    witchSvg.style.filter = 'drop-shadow(0 0 25px #32cd32) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                } else {
                    witchSvg.style.filter = 'drop-shadow(0 5px 15px rgba(0, 0, 0, 0.2))';
                }
            }
            
            // Check level 2 completion
            checkLevel2Completion();
        }

        // Initialize the application
        function init() {
            createNavigation();
            createContent();
            updateDisplay();
            setupEventListeners();
        }

        // Create navigation buttons with level locking
        function createNavigation() {
            const navContainer = document.getElementById('navButtons');
            navContainer.innerHTML = '';
            
            levels.forEach((level, index) => {
                const button = document.createElement('button');
                button.className = 'nav-btn';
                button.textContent = `Level ${index + 1}`;
                
                // Check if level is unlocked
                if (isLevelUnlocked(index)) {
                    button.addEventListener('click', () => goToLevel(index));
                } else {
                    button.classList.add('locked');
                    button.disabled = true;
                    button.title = `Complete Level ${index} to unlock`;
                }
                
                navContainer.appendChild(button);
            });
        }

        // Update navigation to reflect current state
        function updateNavigation() {
            const navButtons = document.querySelectorAll('.nav-btn');
            const completionKeys = ['level1', 'level2', 'level3', 'level4', 'level5', 'level6', 'level7', 'level8', 'level9', 'level10'];
            
            navButtons.forEach((btn, index) => {
                // Reset classes
                btn.classList.remove('active', 'locked', 'completed');
                btn.disabled = false;
                btn.title = '';
                
                // Set current level as active
                if (index === currentLevel) {
                    btn.classList.add('active');
                }
                
                // Mark completed levels
                if (index < completionKeys.length && levelCompletions[completionKeys[index]]) {
                    btn.classList.add('completed');
                }
                
                // Lock inaccessible levels
                if (!isLevelUnlocked(index)) {
                    btn.classList.add('locked');
                    btn.disabled = true;
                    
                    if (index === 5 && levelCompletions.level5 && !trueBoneSize) {
                        btn.title = 'Training data is being generated...';
                    } else if (index === 5 && !levelCompletions.level5) {
                        btn.title = 'Complete Level 5 to unlock training data';
                    } else {
                        btn.title = `Complete Level ${index} to unlock`;
                    }
                }
                
                // Re-add click listener for unlocked levels
                if (isLevelUnlocked(index) && !btn.onclick) {
                    btn.addEventListener('click', () => goToLevel(index));
                }
            });
        }

        // Create content levels
        function createContent() {
            const slider = document.getElementById('contentSlider');
            slider.innerHTML = '';

            levels.forEach((level, index) => {
                const levelElement = document.createElement('div');
                levelElement.className = 'content-part';
                
                if (index === 0) {
                    // Special content for Level 1 - Robot
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>RX-7 Energy Robot</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                <svg id="robotSvg" class="robot-svg" viewBox="0 0 200 250" width="200" height="250">
                                    <!-- Robot Head -->
                                    <rect x="60" y="30" width="80" height="70" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Eyes -->
                                    <circle id="leftEye" cx="80" cy="60" r="8" fill="#333333"/>
                                    <circle id="rightEye" cx="120" cy="60" r="8" fill="#333333"/>
                                    
                                    <!-- Eye pupils -->
                                    <circle cx="80" cy="60" r="3" fill="#ffffff"/>
                                    <circle cx="120" cy="60" r="3" fill="#ffffff"/>
                                    
                                    <!-- Robot Mouth -->
                                    <rect x="90" y="80" width="20" height="5" rx="2" fill="#555"/>
                                    
                                    <!-- Robot Antenna -->
                                    <line x1="100" y1="30" x2="100" y2="15" stroke="#888" stroke-width="3" stroke-linecap="round"/>
                                    <circle cx="100" cy="15" r="4" fill="#ff4757"/>
                                    
                                    <!-- Robot Body -->
                                    <rect x="50" y="100" width="100" height="90" rx="15" fill="#e0e0e0" stroke="#999" stroke-width="2"/>
                                    
                                    <!-- Chest Panel -->
                                    <rect x="70" y="120" width="60" height="40" rx="8" fill="#f5f5f5" stroke="#aaa" stroke-width="1"/>
                                    
                                    <!-- Chest Light -->
                                    <circle id="chestLight" cx="100" cy="140" r="12" fill="#666666" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Control Buttons -->
                                    <circle cx="85" cy="165" r="4" fill="#ff6b6b"/>
                                    <circle cx="100" cy="165" r="4" fill="#4ecdc4"/>
                                    <circle cx="115" cy="165" r="4" fill="#45b7d1"/>
                                    
                                    <!-- Robot Arms -->
                                    <rect x="20" y="120" width="30" height="15" rx="7" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    <rect x="150" y="120" width="30" height="15" rx="7" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Hands -->
                                    <circle cx="15" cy="127" r="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    <circle cx="185" cy="127" r="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    
                                    <!-- Robot Legs -->
                                    <rect x="70" y="190" width="20" height="40" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    <rect x="110" y="190" width="20" height="40" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Feet -->
                                    <ellipse cx="80" cy="240" rx="15" ry="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    <ellipse cx="120" cy="240" rx="15" ry="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                </svg>
                                
                                <div class="energy-control">
                                    <label for="energySlider">Robot Energy Level:</label>
                                    <input type="range" id="energySlider" min="0" max="100" value="50" step="1">
                                    
                                    <div class="energy-display">
                                        <span>Energy:</span>
                                        <div class="energy-bar">
                                            <div id="energyFill" class="energy-fill"></div>
                                        </div>
                                        <span id="energyValue">50%</span>
                                    </div>
                                    
                                    <div id="optimalIndicator" class="optimal-indicator">
                                        Adjusting energy level...
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 1) {
                    // Special content for Level 2 - Witch
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>Sorceress Elara's Brew</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                <svg id="witchSvg" class="robot-svg" viewBox="0 0 200 250" width="200" height="250">
                                    <!-- Fire under cauldron (drawn first, behind everything) -->
                                    <polygon points="145,205 150,220 140,220" fill="#ff4500"/>
                                    <polygon points="155,208 160,225 150,225" fill="#ff6500"/>
                                    <polygon points="165,208 170,225 160,225" fill="#ff6500"/>
                                    <polygon points="175,205 180,220 170,220" fill="#ff4500"/>
                                    
                                    <!-- Cauldron (drawn early so it appears behind witch) -->
                                    <ellipse cx="160" cy="180" rx="35" ry="12" fill="#333" stroke="#111" stroke-width="2"/>
                                    <rect x="125" y="165" width="70" height="15" rx="35" fill="#444" stroke="#111" stroke-width="2"/>
                                    
                                    <!-- Cauldron Legs -->
                                    <rect x="135" y="190" width="4" height="15" fill="#333"/>
                                    <rect x="155" y="190" width="4" height="15" fill="#333"/>
                                    <rect x="180" y="190" width="4" height="15" fill="#333"/>
                                    
                                    <!-- Cauldron Brew -->
                                    <ellipse id="cauldronBrew" cx="160" cy="172" rx="28" ry="8" fill="#654321"/>
                                    
                                    <!-- Cauldron Handles -->
                                    <path d="M 125 170 Q 115 170 115 175 Q 115 180 125 180" stroke="#333" stroke-width="3" fill="none"/>
                                    <path d="M 195 170 Q 205 170 205 175 Q 205 180 195 180" stroke="#333" stroke-width="3" fill="none"/>
                                    
                                    <!-- Witch Dress (lower part, behind cauldron) -->
                                    <polygon points="85,150 115,150 120,200 80,200" fill="#6a1b9a" stroke="#4a148c" stroke-width="2"/>
                                    
                                    <!-- Witch Feet (behind cauldron) -->
                                    <ellipse cx="88" cy="210" rx="8" ry="4" fill="#111"/>
                                    <ellipse cx="112" cy="210" rx="8" ry="4" fill="#111"/>
                                    
                                    <!-- Witch Body -->
                                    <rect x="85" y="100" width="30" height="50" rx="5" fill="#6a1b9a" stroke="#4a148c" stroke-width="2"/>
                                    
                                    <!-- Witch Arms -->
                                    <ellipse cx="75" cy="120" rx="8" ry="20" fill="#6a1b9a" stroke="#4a148c" stroke-width="1"/>
                                    <ellipse cx="125" cy="120" rx="8" ry="20" fill="#6a1b9a" stroke="#4a148c" stroke-width="1"/>
                                    
                                    <!-- Witch Hands -->
                                    <circle cx="70" cy="135" r="5" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    <circle cx="130" cy="135" r="5" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    
                                    <!-- Witch Head -->
                                    <circle cx="100" cy="80" r="20" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    
                                    <!-- Witch Eyes -->
                                    <circle cx="94" cy="76" r="3" fill="#333"/>
                                    <circle cx="106" cy="76" r="3" fill="#333"/>
                                    
                                    <!-- Witch Nose -->
                                    <polygon points="100,82 98,88 102,88" fill="#e0a080"/>
                                    
                                    <!-- Witch Mouth -->
                                    <path d="M 96 90 Q 100 93 104 90" stroke="#333" stroke-width="1" fill="none"/>
                                    
                                    <!-- Witch Hair -->
                                    <path d="M 80 70 Q 75 85 80 95 Q 85 90 85 95" stroke="#8b4513" stroke-width="3" fill="none"/>
                                    <path d="M 120 70 Q 125 85 120 95 Q 115 90 115 95" stroke="#8b4513" stroke-width="3" fill="none"/>
                                    
                                    <!-- Witch Hat (drawn on top) -->
                                    <polygon points="100,10 120,60 80,60" fill="#4a148c" stroke="#37006b" stroke-width="2"/>
                                    <ellipse cx="100" cy="60" rx="25" ry="8" fill="#4a148c" stroke="#37006b" stroke-width="2"/>
                                    <circle cx="118" cy="35" r="3" fill="#ffd700"/>
                                    
                                    <!-- Magic Wand (in front) -->
                                    <line x1="132" y1="132" x2="145" y2="120" stroke="#8b4513" stroke-width="2"/>
                                    <polygon points="145,120 150,115 148,122 152,120" fill="#ffd700"/>
                                    
                                    <!-- Sparkles (on top) -->
                                    <circle cx="155" cy="110" r="1" fill="#ffd700"/>
                                    <circle cx="150" cy="125" r="1" fill="#ffd700"/>
                                    <circle cx="148" cy="115" r="1" fill="#ffd700"/>
                                </svg>
                                
                                <div class="energy-control">
                                    <label>Potion Ingredients:</label>
                                    
                                    <div style="display: flex; gap: 20px; align-items: center;">
                                        <div style="flex: 1;">
                                            <label for="yellowSlider">🟡 Yellow Essence:</label>
                                            <input type="range" id="yellowSlider" min="0" max="100" value="30" step="1" style="width: 100%;">
                                            <div style="text-align: center; margin-top: 5px;">
                                                <span id="yellowValue">30%</span>
                                            </div>
                                        </div>
                                        
                                        <div style="flex: 1;">
                                            <label for="blueSlider">🔵 Blue Essence:</label>
                                            <input type="range" id="blueSlider" min="0" max="100" value="20" step="1" style="width: 100%;">
                                            <div style="text-align: center; margin-top: 5px;">
                                                <span id="blueValue">20%</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div id="brewIndicator" class="optimal-indicator">
                                        Mixing potions...
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 2) {
                    // Special content for Level 3 - AI Robot with Gradient Descent
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>AI-Powered RX-7 Robot</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                <svg id="robotSvgAI" class="robot-svg" viewBox="0 0 200 250" width="200" height="250">
                                    <!-- Robot Head -->
                                    <rect x="60" y="30" width="80" height="70" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Eyes -->
                                    <circle id="leftEyeAI" cx="80" cy="60" r="8" fill="#333333"/>
                                    <circle id="rightEyeAI" cx="120" cy="60" r="8" fill="#333333"/>
                                    
                                    <!-- Eye pupils -->
                                    <circle cx="80" cy="60" r="3" fill="#ffffff"/>
                                    <circle cx="120" cy="60" r="3" fill="#ffffff"/>
                                    
                                    <!-- Robot Mouth -->
                                    <rect x="90" y="80" width="20" height="5" rx="2" fill="#555"/>
                                    
                                    <!-- Robot Antenna -->
                                    <line x1="100" y1="30" x2="100" y2="15" stroke="#888" stroke-width="3" stroke-linecap="round"/>
                                    <circle cx="100" cy="15" r="4" fill="#ff4757"/>
                                    
                                    <!-- AI Brain Symbol -->
                                    <circle cx="100" cy="50" r="3" fill="#667eea"/>
                                    <text x="100" y="55" text-anchor="middle" font-size="8" fill="#667eea">AI</text>
                                    
                                    <!-- Robot Body -->
                                    <rect x="50" y="100" width="100" height="90" rx="15" fill="#e0e0e0" stroke="#999" stroke-width="2"/>
                                    
                                    <!-- Chest Panel -->
                                    <rect x="70" y="120" width="60" height="40" rx="8" fill="#f5f5f5" stroke="#aaa" stroke-width="1"/>
                                    
                                    <!-- Chest Light -->
                                    <circle id="chestLightAI" cx="100" cy="140" r="12" fill="#666666" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Control Buttons -->
                                    <circle cx="85" cy="165" r="4" fill="#ff6b6b"/>
                                    <circle cx="100" cy="165" r="4" fill="#4ecdc4"/>
                                    <circle cx="115" cy="165" r="4" fill="#45b7d1"/>
                                    
                                    <!-- Robot Arms -->
                                    <rect x="20" y="120" width="30" height="15" rx="7" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    <rect x="150" y="120" width="30" height="15" rx="7" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Hands -->
                                    <circle cx="15" cy="127" r="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    <circle cx="185" cy="127" r="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    
                                    <!-- Robot Legs -->
                                    <rect x="70" y="190" width="20" height="40" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    <rect x="110" y="190" width="20" height="40" rx="10" fill="#c0c0c0" stroke="#888" stroke-width="2"/>
                                    
                                    <!-- Robot Feet -->
                                    <ellipse cx="80" cy="240" rx="15" ry="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                    <ellipse cx="120" cy="240" rx="15" ry="8" fill="#a0a0a0" stroke="#777" stroke-width="2"/>
                                </svg>
                                
                                <div class="energy-control">
                                    <label for="energySliderAI">Robot Energy Level:</label>
                                    <input type="range" id="energySliderAI" min="0" max="100" value="30" step="1">
                                    
                                    <div class="energy-display">
                                        <span>Energy:</span>
                                        <div class="energy-bar">
                                            <div id="energyFillAI" class="energy-fill"></div>
                                        </div>
                                        <span id="energyValueAI">30%</span>
                                    </div>
                                    
                                    <button id="gradientDescentBtn" class="gradient-btn">
                                        🤖 Gradient Descent Step
                                    </button>
                                    <button id="resetOptimizationBtn" class="reset-btn">
                                        🔄 Reset
                                    </button>
                                    
                                    <div id="aiIndicator" class="optimal-indicator">
                                        🤖 Current Loss: 3600.00 | Target: 90%
                                    </div>
                                    
                                    <div id="stepInfo" class="step-info">
                                        <strong>Advanced Optimization Engine</strong><br>
                                        Displays: Loss | Gradient | Raw Step | Actual Step<br>
                                        <small>Prevents rounding-stuck | Exact convergence only</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 3) {
                    // Special content for Level 4 - Multi-Potion Witch with 5 ingredients
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>Master Alchemist Elara</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                <svg id="witchSvgMulti" class="robot-svg" viewBox="0 0 200 250" width="200" height="250">
                                    <!-- Witch Hat -->
                                    <polygon points="100,10 120,60 80,60" fill="#4a148c" stroke="#37006b" stroke-width="2"/>
                                    <ellipse cx="100" cy="60" rx="25" ry="8" fill="#4a148c" stroke="#37006b" stroke-width="2"/>
                                    <circle cx="118" cy="35" r="3" fill="#ffd700"/>
                                    <circle cx="115" cy="45" r="2" fill="#ffd700"/>
                                    <circle cx="112" cy="25" r="1.5" fill="#ffd700"/>
                                    
                                    <!-- Witch Head -->
                                    <circle cx="100" cy="80" r="20" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    
                                    <!-- Witch Eyes -->
                                    <circle cx="94" cy="76" r="3" fill="#333"/>
                                    <circle cx="106" cy="76" r="3" fill="#333"/>
                                    <circle cx="94" cy="75" r="1" fill="#fff"/>
                                    <circle cx="106" cy="75" r="1" fill="#fff"/>
                                    
                                    <!-- Witch Nose -->
                                    <polygon points="100,82 98,88 102,88" fill="#e0a080"/>
                                    
                                    <!-- Witch Mouth -->
                                    <path d="M 96 90 Q 100 93 104 90" stroke="#333" stroke-width="1" fill="none"/>
                                    
                                    <!-- Enhanced Witch Hair -->
                                    <path d="M 80 70 Q 75 85 80 95 Q 85 90 85 95" stroke="#8b4513" stroke-width="4" fill="none"/>
                                    <path d="M 120 70 Q 125 85 120 95 Q 115 90 115 95" stroke="#8b4513" stroke-width="4" fill="none"/>
                                    <path d="M 85 65 Q 80 75 85 85" stroke="#8b4513" stroke-width="2" fill="none"/>
                                    <path d="M 115 65 Q 120 75 115 85" stroke="#8b4513" stroke-width="2" fill="none"/>
                                    
                                    <!-- Witch Body -->
                                    <rect x="85" y="100" width="30" height="50" rx="5" fill="#6a1b9a" stroke="#4a148c" stroke-width="2"/>
                                    
                                    <!-- Witch Arms -->
                                    <ellipse cx="75" cy="120" rx="8" ry="20" fill="#6a1b9a" stroke="#4a148c" stroke-width="1"/>
                                    <ellipse cx="125" cy="120" rx="8" ry="20" fill="#6a1b9a" stroke="#4a148c" stroke-width="1"/>
                                    
                                    <!-- Witch Hands -->
                                    <circle cx="70" cy="135" r="5" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    <circle cx="130" cy="135" r="5" fill="#f4c2a1" stroke="#e0a080" stroke-width="1"/>
                                    
                                    <!-- Enhanced Magic Wand -->
                                    <line x1="132" y1="132" x2="148" y2="118" stroke="#8b4513" stroke-width="3"/>
                                    <polygon points="148,118 154,112 152,120 158,118" fill="#ffd700"/>
                                    
                                    <!-- Enhanced Sparkles -->
                                    <circle cx="160" cy="108" r="2" fill="#ffd700"/>
                                    <circle cx="155" cy="125" r="1.5" fill="#ff69b4"/>
                                    <circle cx="152" cy="115" r="1" fill="#00ffff"/>
                                    <circle cx="145" cy="110" r="1" fill="#ff4500"/>
                                    <circle cx="150" cy="105" r="1.5" fill="#9370db"/>
                                    
                                    <!-- Magical Aura Lines -->
                                    <path d="M 145 125 Q 150 120 155 125" stroke="#ffd700" stroke-width="1" fill="none" opacity="0.7"/>
                                    <path d="M 150 130 Q 155 125 160 130" stroke="#ff69b4" stroke-width="1" fill="none" opacity="0.7"/>
                                    
                                    <!-- Enhanced Cauldron -->
                                    <ellipse cx="160" cy="180" rx="40" ry="15" fill="#333" stroke="#111" stroke-width="2"/>
                                    <rect x="120" y="165" width="80" height="18" rx="40" fill="#444" stroke="#111" stroke-width="2"/>
                                    
                                    <!-- Cauldron Legs -->
                                    <rect x="130" y="190" width="5" height="18" fill="#333"/>
                                    <rect x="155" y="190" width="5" height="18" fill="#333"/>
                                    <rect x="185" y="190" width="5" height="18" fill="#333"/>
                                    
                                    <!-- Enhanced Cauldron Brew -->
                                    <ellipse id="cauldronBrewMulti" cx="160" cy="172" rx="32" ry="10" fill="#654321"/>
                                    
                                    <!-- Cauldron Decorations -->
                                    <circle cx="140" cy="175" r="3" fill="#666" stroke="#333" stroke-width="1"/>
                                    <circle cx="180" cy="175" r="3" fill="#666" stroke="#333" stroke-width="1"/>
                                    
                                    <!-- Cauldron Handles -->
                                    <path d="M 120 170 Q 110 170 110 175 Q 110 180 120 180" stroke="#333" stroke-width="4" fill="none"/>
                                    <path d="M 200 170 Q 210 170 210 175 Q 210 180 200 180" stroke="#333" stroke-width="4" fill="none"/>
                                    
                                    <!-- Enhanced Fire under cauldron -->
                                    <polygon points="140,205 145,225 135,225" fill="#ff4500"/>
                                    <polygon points="150,208 155,230 145,230" fill="#ff6500"/>
                                    <polygon points="160,210 165,232 155,232" fill="#ff8500"/>
                                    <polygon points="170,208 175,230 165,230" fill="#ff6500"/>
                                    <polygon points="180,205 185,225 175,225" fill="#ff4500"/>
                                    
                                    <!-- Fire Sparks -->
                                    <circle cx="148" cy="200" r="1" fill="#ffff00"/>
                                    <circle cx="162" cy="198" r="1" fill="#ffff00"/>
                                    <circle cx="172" cy="202" r="1" fill="#ffff00"/>
                                    
                                    <!-- Witch Dress -->
                                    <polygon points="85,150 115,150 120,200 80,200" fill="#6a1b9a" stroke="#4a148c" stroke-width="2"/>
                                    
                                    <!-- Dress Details -->
                                    <line x1="90" y1="160" x2="110" y2="160" stroke="#9c27b0" stroke-width="2"/>
                                    <line x1="88" y1="170" x2="112" y2="170" stroke="#9c27b0" stroke-width="2"/>
                                    <line x1="86" y1="180" x2="114" y2="180" stroke="#9c27b0" stroke-width="2"/>
                                    
                                    <!-- Witch Feet -->
                                    <ellipse cx="88" cy="210" rx="10" ry="5" fill="#111"/>
                                    <ellipse cx="112" cy="210" rx="10" ry="5" fill="#111"/>
                                    
                                    <!-- Shoe Details -->
                                    <ellipse cx="88" cy="209" rx="6" ry="3" fill="#333"/>
                                    <ellipse cx="112" cy="209" rx="6" ry="3" fill="#333"/>
                                </svg>
                                
                                <div class="energy-control">
                                    <label>Master Alchemist's 5 Essential Ingredients:</label>
                                    
                                    <div class="potion-grid">
                                        <div class="potion-control">
                                            <label for="redSliderMulti">🔴 Crimson Essence:</label>
                                            <input type="range" id="redSliderMulti" min="0" max="100" value="20" step="1">
                                            <div class="potion-value">
                                                <span id="redValueMulti">20%</span>
                                            </div>
                                        </div>
                                        
                                        <div class="potion-control">
                                            <label for="yellowSliderMulti">🟡 Golden Essence:</label>
                                            <input type="range" id="yellowSliderMulti" min="0" max="100" value="30" step="1">
                                            <div class="potion-value">
                                                <span id="yellowValueMulti">30%</span>
                                            </div>
                                        </div>
                                        
                                        <div class="potion-control">
                                            <label for="greenSliderMulti">🟢 Emerald Essence:</label>
                                            <input type="range" id="greenSliderMulti" min="0" max="100" value="40" step="1">
                                            <div class="potion-value">
                                                <span id="greenValueMulti">40%</span>
                                            </div>
                                        </div>
                                        
                                        <div class="potion-control">
                                            <label for="blueSliderMulti">🔵 Sapphire Essence:</label>
                                            <input type="range" id="blueSliderMulti" min="0" max="100" value="50" step="1">
                                            <div class="potion-value">
                                                <span id="blueValueMulti">50%</span>
                                            </div>
                                        </div>
                                        
                                        <div class="potion-control purple-potion">
                                            <label for="purpleSliderMulti">🟣 Violet Essence:</label>
                                            <input type="range" id="purpleSliderMulti" min="0" max="100" value="60" step="1">
                                            <div class="potion-value">
                                                <span id="purpleValueMulti">60%</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 100%;">
                                        <button id="gradientDescentMultiBtn" class="gradient-btn">
                                            🧙‍♀️ Multi-Potion Optimization
                                        </button>
                                        <button id="resetMultiBtn" class="reset-btn">
                                            🔄 New Recipe
                                        </button>
                                    </div>
                                    
                                    <div id="multiBrewIndicator" class="optimal-indicator">
                                        🔬 Total Loss: 8500.0 | Quality: 15.2%
                                    </div>
                                    
                                    <div id="multiStepInfo" class="step-info">
                                        <strong>Advanced 5-Variable Optimization</strong><br>
                                        Targets: 70%, 60%, 50%, 40%, 30%<br>
                                        <small>Multi-dimensional gradient descent | Real-time loss tracking</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 4) {
                    // Special content for Level 5 - Dog Bone Buying (Blind)
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>Meet Max - He Needs a Bone!</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                <svg class="robot-svg" viewBox="0 0 200 250" width="200" height="250">
                                    <!-- Dog body -->
                                    <ellipse cx="100" cy="160" rx="50" ry="35" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                                    
                                    <!-- Dog head -->
                                    <circle cx="100" cy="100" r="35" fill="#A0522D" stroke="#654321" stroke-width="2"/>
                                    
                                    <!-- Dog ears -->
                                    <ellipse cx="75" cy="80" rx="12" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(-20 75 80)"/>
                                    <ellipse cx="125" cy="80" rx="12" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(20 125 80)"/>
                                    
                                    <!-- Dog eyes -->
                                    <circle cx="88" cy="95" r="6" fill="black"/>
                                    <circle cx="112" cy="95" r="6" fill="black"/>
                                    <circle cx="90" cy="93" r="2" fill="white"/>
                                    <circle cx="114" cy="93" r="2" fill="white"/>
                                    
                                    <!-- Dog nose -->
                                    <ellipse cx="100" cy="108" rx="4" ry="3" fill="black"/>
                                    
                                    <!-- Dog mouth -->
                                    <path d="M 100 112 Q 92 118 88 115" stroke="black" stroke-width="2" fill="none"/>
                                    <path d="M 100 112 Q 108 118 112 115" stroke="black" stroke-width="2" fill="none"/>
                                    
                                    <!-- Dog tongue -->
                                    <ellipse cx="100" cy="120" rx="8" ry="4" fill="#FF69B4"/>
                                    
                                    <!-- Dog legs -->
                                    <rect x="70" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="90" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="110" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="130" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    
                                    <!-- Dog paws -->
                                    <ellipse cx="76" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="96" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="116" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="136" cy="232" rx="8" ry="5" fill="#654321"/>
                                    
                                    <!-- Dog tail -->
                                    <ellipse cx="160" cy="150" rx="8" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(30 160 150)"/>
                                    
                                    <!-- Dog collar -->
                                    <rect x="80" y="125" width="40" height="8" rx="4" fill="#FF0000" stroke="#CC0000" stroke-width="1"/>
                                    <circle cx="120" cy="129" r="3" fill="#FFD700" stroke="#DAA520" stroke-width="1"/>
                                    
                                    <!-- Question mark above dog -->
                                    <text x="140" y="70" font-family="Arial" font-size="24" fill="#666" font-weight="bold">?</text>
                                    <circle cx="140" cy="75" r="15" fill="none" stroke="#666" stroke-width="2" opacity="0.5"/>
                                </svg>
                                
                                <div class="energy-control">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <label>💰 Money:</label>
                                        <span id="moneyDisplay" style="font-size: 1.5rem; font-weight: bold; color: #2ed573;">$10</span>
                                    </div>
                                    
                                    <label for="boneSizeSlider">🦴 Bone Size (inches):</label>
                                    <input type="range" id="boneSizeSlider" min="5" max="95" value="50" step="1">
                                    
                                    <div class="energy-display">
                                        <span>Size:</span>
                                        <span id="boneSizeValue" style="font-weight: bold; color: #667eea;">50 inches</span>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                                        <button id="buyBoneBtn" class="gradient-btn" style="flex: 1;">
                                            🛒 Buy Bone ($5)
                                        </button>
                                        <button id="gradientDescentDisabledBtn" class="gradient-btn" style="flex: 1; opacity: 0.5; cursor: not-allowed;" disabled>
                                            🤖 Gradient Descent
                                        </button>
                                    </div>
                                    
                                    <div id="dogFeedback" class="optimal-indicator">
                                        🐕 Max is waiting for his bone! What size do you think he'll like?<br>
                                        <small>💡 Without knowing his preference, this is just a guess...</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 5) {
                    // Special content for Level 6 - Dog Bone Buying with Training Data
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>Second Chance with Training Data!</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                
                                <div id="trainingDogs" style="background: rgba(255,255,255,0.9); border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                                    <div style="text-align: center; color: #666;">Loading training data...</div>
                                </div>
                                
                                <svg class="robot-svg" viewBox="0 0 200 250" width="200" height="200">
                                    <!-- Same dog as Level 5 but with a lightbulb above showing he's learned -->
                                    <ellipse cx="100" cy="160" rx="50" ry="35" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                                    <circle cx="100" cy="100" r="35" fill="#A0522D" stroke="#654321" stroke-width="2"/>
                                    <ellipse cx="75" cy="80" rx="12" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(-20 75 80)"/>
                                    <ellipse cx="125" cy="80" rx="12" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(20 125 80)"/>
                                    <circle cx="88" cy="95" r="6" fill="black"/>
                                    <circle cx="112" cy="95" r="6" fill="black"/>
                                    <circle cx="90" cy="93" r="2" fill="white"/>
                                    <circle cx="114" cy="93" r="2" fill="white"/>
                                    <ellipse cx="100" cy="108" rx="4" ry="3" fill="black"/>
                                    <path d="M 100 112 Q 92 118 88 115" stroke="black" stroke-width="2" fill="none"/>
                                    <path d="M 100 112 Q 108 118 112 115" stroke="black" stroke-width="2" fill="none"/>
                                    <ellipse cx="100" cy="120" rx="8" ry="4" fill="#FF69B4"/>
                                    <rect x="70" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="90" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="110" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <rect x="130" y="190" width="12" height="35" rx="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                                    <ellipse cx="76" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="96" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="116" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="136" cy="232" rx="8" ry="5" fill="#654321"/>
                                    <ellipse cx="160" cy="150" rx="8" ry="25" fill="#8B4513" stroke="#654321" stroke-width="2" transform="rotate(30 160 150)"/>
                                    <rect x="80" y="125" width="40" height="8" rx="4" fill="#FF0000" stroke="#CC0000" stroke-width="1"/>
                                    <circle cx="120" cy="129" r="3" fill="#FFD700" stroke="#DAA520" stroke-width="1"/>
                                    
                                    <!-- Lightbulb showing insight -->
                                    <circle cx="140" cy="70" r="8" fill="#FFD700" stroke="#DAA520" stroke-width="2"/>
                                    <rect x="137" y="75" width="6" height="4" fill="#DAA520"/>
                                    <line x1="132" y1="65" x2="148" y2="65" stroke="#DAA520" stroke-width="1"/>
                                    <line x1="134" y1="68" x2="146" y2="68" stroke="#DAA520" stroke-width="1"/>
                                    <text x="140" y="90" font-family="Arial" font-size="10" fill="#666" text-anchor="middle">Insight!</text>
                                </svg>
                                
                                <div class="energy-control">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <label>💰 Money:</label>
                                        <span id="moneyDisplay" style="font-size: 1.5rem; font-weight: bold; color: #2ed573;">$5</span>
                                    </div>
                                    
                                    <label for="boneSizeSliderPart6">🦴 Bone Size (inches):</label>
                                    <input type="range" id="boneSizeSliderPart6" min="5" max="95" value="50" step="1">
                                    
                                    <div class="energy-display">
                                        <span>Size:</span>
                                        <span id="boneSizeValuePart6" style="font-weight: bold; color: #667eea;">50 inches</span>
                                    </div>
                                    
                                    <button id="buyBoneBtn2" class="gradient-btn" style="width: 100%; margin-top: 15px;">
                                        🛒 Buy Final Bone ($5)
                                    </button>
                                    
                                    <div id="dogFeedback2" class="optimal-indicator">
                                        🎯 Now you have data! Use the training information to make a better guess for Max.<br>
                                        <small>📊 Machine learning works best with good training data!</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 6) {
                    // Special content for Level 7 - Large Scale Prediction (Bad)
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>1000 Robot Factory</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                
                                <div class="robot-grid" id="robotGrid7">
                                    <!-- Grid will be populated by JavaScript -->
                                </div>
                                
                                <div class="prediction-controls">
                                    <button id="usePredictionBtn7" class="gradient-btn">
                                        🔮 Use Basic Prediction Model
                                    </button>
                                </div>
                                
                                <div id="predictionStats7" class="prediction-stats">
                                    📊 <strong>1000 robots waiting for activation...</strong><br>
                                    <small>Click "Use Basic Prediction Model" to see how your simple model performs at scale!</small>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 7) {
                    // Special content for Level 8 - Feature Engineering  
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>Feature Engineering Lab</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                
                                <div class="feature-robots" id="featureRobots">
                                    <!-- Feature robots will be populated by JavaScript -->
                                </div>
                                
                                <div class="feature-function">
                                    <h4>🧮 Energy Function</h4>
                                    <div class="weight-display">
                                        Energy = <span id="weightA">0.50</span> × Height + <span id="weightB">0.30</span> × Head Size + <span id="weightC">0.20</span> × Eye Glow
                                    </div>
                                    <div class="loss-display">
                                        Current Loss: <span id="currentLoss">Calculating...</span>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
                                        <button id="optimizeWeightsBtn" class="gradient-btn">
                                            🔬 Optimize Weights
                                        </button>
                                        <button id="resetWeightsBtn" class="reset-btn">
                                            🔄 Reset Weights
                                        </button>
                                    </div>
                                    
                                    <div id="weightStepInfo" class="step-info">
                                        <strong>Feature Weight Optimization</strong><br>
                                        Optimizing: A (Height), B (Head Size), C (Eye Glow)<br>
                                        <small>Find the perfect combination to predict each robot's energy requirement!</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (index === 8) {
                    // Special content for Level 9 - Large Scale Prediction (Good)
                    levelElement.innerHTML = `
                        <div class="robot-container">
                            <div class="robot-section">
                                <h3>1000 Robot Factory - Optimized Model</h3>
                                <div class="level-goal">
                                    🎯 <strong>Goal:</strong> ${level.goal}
                                </div>
                                
                                <div class="robot-grid" id="robotGrid9">
                                    <!-- Grid will be populated by JavaScript -->
                                </div>
                                
                                <div class="prediction-controls">
                                    <button id="usePredictionBtn9" class="gradient-btn">
                                        🚀 Use Optimized Prediction Model
                                    </button>
                                </div>
                                
                                <div id="predictionStats9" class="prediction-stats">
                                    🎯 <strong>1000 robots ready for optimized predictions...</strong><br>
                                    <small>See the dramatic improvement from proper feature engineering!</small>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Regular content for other levels (when they get implemented)
                    levelElement.innerHTML = `
                        <div class="part-content">
                            <h2 class="part-title">${level.title}</h2>
                            <div class="level-goal">
                                🎯 <strong>Goal:</strong> ${level.goal}
                            </div>
                            <p class="part-description">${level.description}</p>
                            <p class="part-details">${level.details}</p>
                        </div>
                    `;
                }
                
                slider.appendChild(levelElement);
            });
            
            // Setup energy control after content is created
            setupEnergyControl();
        }

        // Update display based on current level
        function updateDisplay() {
            // Update slider position
            const slider = document.getElementById('contentSlider');
            slider.style.transform = `translateX(-${currentLevel * 100}%)`;

            // Update navigation
            updateNavigation();

            // Update arrow visibility
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            prevBtn.disabled = currentLevel === 0;
            nextBtn.disabled = currentLevel === levels.length - 1 || !isLevelUnlocked(currentLevel + 1);
            
            // Update money display for dog levels
            if (currentLevel === 4 || currentLevel === 5) {
                updateMoneyDisplay();
            }
        }

        // Navigate to specific level
        function goToLevel(levelIndex) {
            if (levelIndex >= 0 && levelIndex < levels.length && isLevelUnlocked(levelIndex)) {
                currentLevel = levelIndex;
                updateDisplay();
            }
        }

        // Navigate to next level
        function nextLevel() {
            if (currentLevel < levels.length - 1 && isLevelUnlocked(currentLevel + 1)) {
                currentLevel++;
                updateDisplay();
            }
        }

        // Navigate to previous level
        function prevLevel() {
            if (currentLevel > 0) {
                currentLevel--;
                updateDisplay();
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            document.getElementById('nextBtn').addEventListener('click', nextLevel);
            document.getElementById('prevBtn').addEventListener('click', prevLevel);

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowLeft':
                        prevLevel();
                        break;
                    case 'ArrowRight':
                        nextLevel();
                        break;
                    case 'Home':
                        goToLevel(0);
                        break;
                    case 'End':
                        // Go to highest unlocked level
                        let highestUnlocked = 0;
                        for (let i = levels.length - 1; i >= 0; i--) {
                            if (isLevelUnlocked(i)) {
                                highestUnlocked = i;
                                break;
                            }
                        }
                        goToLevel(highestUnlocked);
                        break;
                }
            });

            // Touch/swipe support for mobile
            let startX = 0;
            let endX = 0;

            document.addEventListener('touchstart', (e) => {
                startX = e.changedTouches[0].screenX;
            });

            document.addEventListener('touchend', (e) => {
                endX = e.changedTouches[0].screenX;
                handleSwipe();
            });

            function handleSwipe() {
                const threshold = 50;
                const diff = startX - endX;
                
                if (Math.abs(diff) > threshold) {
                    if (diff > 0) {
                        nextLevel(); // Swipe left - go to next
                    } else {
                        prevLevel(); // Swipe right - go to previous
                    }
                }
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>